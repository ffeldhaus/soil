from typing import Optional, Any, Dict
from uuid import UUID, uuid4
from datetime import datetime

from pydantic import BaseModel, Field, ConfigDict

from .financials import TotalIncome, TotalExpenses # Import from the new financials.py
# from .round import RoundSimple # For linking back to the round, if needed
# from .parcel import ParcelOutcome # Could be a simplified parcel state for results

class ResultBase(BaseModel):
    """
    Base properties for the results of a player's round.
    """
    game_id: str = Field(..., description="ID of the game")
    player_id: str = Field(..., description="UID of the player")
    round_number: int = Field(..., ge=1, description="The round number these results pertain to")

    # Key outcomes of the round
    profit_or_loss: float = Field(0.0, description="Net profit or loss for this round (Income - Expenses)")
    closing_capital: float = Field(0.0, description="Total capital at the end of this round")
    starting_capital: float = Field(0.0, description="Total capital at the start of this round (after previous round's results)")
    
    # Ecological / Game Mechanic Outcomes determined by game logic
    achieved_organic_certification: bool = Field(False, description="Whether organic certification was achieved/maintained this round")
    weather_event: Optional[str] = Field(None, description="Weather event that occurred this round (e.g., Normal, Drought)")
    vermin_event: Optional[str] = Field(None, description="Vermin event that occurred this round (e.g., None, Aphids)")
    
    # Aggregated machine state if it changes globally for the player
    player_machine_efficiency: Optional[float] = Field(
        None,
        description="Player's overall machine efficiency at the end of this round / start of next"
    )
    
    # Financial details
    income_details: TotalIncome = Field(default_factory=TotalIncome)
    expense_details: TotalExpenses = Field(default_factory=TotalExpenses)

    # Explanations for key outcomes (I18N keys or direct text)
    # This is a new feature consideration
    explanations: Optional[Dict[str, str]] = Field(
        default_factory=dict,
        description="Key-value pairs of outcomes and their explanations (e.g., 'harvest_low': 'Drought reduced potato yield.')"
    )


class ResultCreate(ResultBase):
    """
    Schema for creating a new result document.
    Results are typically generated by the system after a round is processed.
    """
    # Most fields will be calculated by the game logic.
    # It might take initial capital from the previous round's result.
    pass


# No ResultUpdate schema is typically needed as results are usually immutable once calculated.
# If corrections are needed, it might involve recalculating and replacing the document.


class ResultInDBBase(ResultBase):
    """
    Base properties for a Result as stored in the database.
    The ID could be composite (gameID_playerID_roundNumber) or an auto-ID.
    """
    id: str = Field(..., description="Unique ID for the result document") # e.g., gameID_playerID_roundNumber or Firestore auto-ID
    
    # Reference to the specific decisions that led to this result
    # round_decisions_id: Optional[str] = Field(None, description="ID of the Round document containing player decisions")

    # Timestamps
    calculated_at: datetime = Field(default_factory=lambda: datetime.now(datetime.UTC))

    model_config = ConfigDict(from_attributes=True)


class ResultInDB(ResultInDBBase):
    """
    Represents a Result object as stored in the database.
    """
    pass


class ResultPublic(ResultInDBBase):
    """
    Properties of a Result to return to the client.
    """
    # Inherits most fields.
    # Detailed financial breakdowns (income_details, expense_details) are included.
    # previous_round_summary: Optional[RoundSimple] = None # Could link to a summary of previous round's decisions
    pass