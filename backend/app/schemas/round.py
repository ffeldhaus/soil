from typing import Optional, List, Any, Dict
from uuid import UUID, uuid4
from datetime import datetime

from pydantic import BaseModel, Field, ConfigDict

# from .parcel import ParcelState # To be created
# from .result import ResultSummary # To be created

class RoundDecisionBase(BaseModel):
    """
    Base schema for decisions a player makes in a round.
    """
    # Agricultural practice decisions
    fertilize: bool = Field(False, description="Conventional fertilizer applied this round")
    pesticide: bool = Field(False, description="Pesticides applied this round")
    biological_control: bool = Field(False, description="Biological pest control (beneficial organisms) applied") # Renamed from 'organisms'
    
    # Organic farming choice
    attempt_organic_certification: bool = Field(False, description="Attempting to achieve/maintain organic certification this round")
    
    # Machinery investment/usage
    machine_investment_level: int = Field(
        0,
        ge=0,
        le=50, # Example max, could be percentage increase or fixed levels
        description="Level of investment in new machinery or increased machine usage (e.g., 0-50%)"
    )
    # Tillage_practice: Optional[str] = Field(None, description="e.g., 'conventional', 'reduced', 'no-till'") # Potential future addition

    # Plantation choices will be per parcel, not a single round decision.

class RoundBase(BaseModel):
    """
    Base properties for a Round.
    A round document would typically exist for each player for each round number within a game.
    """
    game_id: str = Field(..., description="ID of the game this round belongs to")
    player_id: str = Field(..., description="UID of the player this round belongs to")
    round_number: int = Field(..., ge=1, description="The sequential number of this round in the game")

    # Decisions made by the player for this round
    decisions: Optional[RoundDecisionBase] = Field(None, description="Player's decisions for this round")

    is_submitted: bool = Field(False, description="Whether the player has submitted their decisions for this round")
    submitted_at: Optional[datetime] = Field(None, description="Timestamp when the round was submitted")

    # Game state snapshot at the *start* of this player's round (after previous round's calculations)
    # This might include things like their capital, overall soil health average, etc.
    # Or this could be part of a more complex ResultFromPreviousRound schema.
    # start_capital: Optional[float] = Field(None, description="Capital at the start of this player's round")

    model_config = ConfigDict(use_enum_values=True)


class RoundCreate(RoundBase):
    """
    Properties to receive when creating a round instance for a player.
    This is typically done automatically when a new game round starts for all players.
    Initial decisions might be empty.
    """
    # id: str = Field(default_factory=lambda: str(uuid4()), description="Unique ID for the round document") # Firestore can auto-generate
    decisions: RoundDecisionBase = Field(default_factory=RoundDecisionBase, description="Initial (default) decisions for the round")
    # is_submitted will be False by default

class RoundUpdate(BaseModel): # Player submits their decisions
    """
    Properties to receive when a player updates their round (submits decisions).
    """
    decisions: RoundDecisionBase = Field(..., description="Player's decisions for this round")
    is_submitted: bool = Field(True, description="Mark round as submitted") # Player sets this to true

    model_config = ConfigDict(extra='forbid')


class RoundInDBBase(RoundBase):
    """
    Base properties for a Round as stored in the database.
    The ID would be a composite like <game_id>_<player_id>_<round_number> or an auto-ID.
    """
    id: str = Field(..., description="Unique ID for the round document (e.g., auto-generated by Firestore or composite)")
    
    # Timestamps
    created_at: datetime = Field(default_factory=lambda: datetime.now(datetime.UTC))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(datetime.UTC)) # When decisions were last saved/submitted

    # Results of this round's calculations (populated after all players submit or round ends)
    # This links to a more detailed result document/sub-collection.
    # result_id: Optional[str] = Field(None, description="ID of the Result document for this player's round")

    # Field state at the end of this round (after calculations)
    # This could be a list of ParcelState or a reference to a field snapshot document.
    # final_parcels_state_id: Optional[str] = Field(None, description="ID of the FieldState document at the end of this round")

    model_config = ConfigDict(from_attributes=True)


class RoundInDB(RoundInDBBase):
    """
    Represents a Round object as stored in the database.
    """
    pass


class RoundPublic(RoundInDBBase):
    """
    Properties to return to the client for a round.
    """
    # Inherits most fields.
    # Sensitive data or overly complex objects might be summarized or excluded.
    # Example: Instead of full parcel details, maybe just a summary or parcel_ids.
    # current_parcels_state: Optional[List[ParcelState]] = None
    # round_result_summary: Optional[ResultSummary] = None # Summary of financial/ecological outcomes
    pass

# A simpler representation, perhaps for listing rounds or in game overview
class RoundSimple(BaseModel):
    id: str
    game_id: str
    player_id: str
    round_number: int
    is_submitted: bool
    submitted_at: Optional[datetime] = None

    model_config = ConfigDict(from_attributes=True)