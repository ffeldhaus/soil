from typing import Any, Dict, List, Optional, Union
from uuid import uuid4
from datetime import datetime, timezone # Added

from google.cloud.firestore_v1.async_client import AsyncClient as AsyncFirestoreClient
from google.cloud.firestore_v1.base_client import BaseClient # For type hint of sync client
from google.cloud.firestore_v1.async_query import AsyncQuery


from app.crud.base import CRUDBase
from app.schemas.game import GameCreate, GameUpdate, GameInDB
from app.core.config import settings # For default game settings
from app.game_logic import game_rules # We'll create this later for weather/vermin sequences

# Collection name in Firestore for games
GAME_COLLECTION = "games"

class CRUDGame(CRUDBase[GameInDB, GameCreate, GameUpdate]):
    """
    CRUD operations for Game sessions stored in Firestore.
    """

    async def create_with_admin(
        self,
        db: Union[AsyncFirestoreClient, BaseClient],
        *,
        obj_in: GameCreate,
        admin_id: str
    ) -> Dict[str, Any]:
        """
        Create a new game document in Firestore.
        Generates weather and vermin sequences for the game.
        The document ID for the game will be auto-generated by Firestore or set from obj_in if provided.
        """
        game_data = obj_in.model_dump(exclude_unset=True)
        game_data["admin_id"] = admin_id
        game_data["current_round_number"] = 0 # Game starts at round 0 (setup) or 1
        game_data["game_status"] = "pending" # Initial status
        game_data["player_uids"] = [] # Initialize with no players; players will be added separately

        # Generate weather and vermin sequences based on number_of_rounds
        num_rounds = obj_in.number_of_rounds
        game_data["weather_sequence"] = game_rules.generate_weather_sequence(num_rounds)
        game_data["vermin_sequence"] = game_rules.generate_vermin_sequence(num_rounds)
        
        # Use the `create` method from CRUDBase which handles auto-ID or specified ID.
        # If GameCreate schema had an `id` field that could be set, CRUDBase.create would use it.
        # Otherwise, it lets Firestore auto-generate an ID.
        # For games, an auto-generated ID is fine.
        # We are passing a dictionary here to `super().create`.
        created_game_data = await super().create(db, obj_in=game_data)
        return created_game_data


    async def get_games_by_admin_id(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, admin_id: str, limit: int = 100
    ) -> List[GameInDB]:
        """
        Get all games created by a specific admin.
        Requires an index on 'admin_id'.
        """
        query: AsyncQuery = db.collection(self.collection_name).where(
            field="admin_id", op_string="==", value=admin_id
        ).limit(limit) # Add .order_by("created_at", direction="DESCENDING") if desired (needs composite index)
        
        results = []
        async for snapshot in query.stream(): # type: ignore
            if snapshot.exists:
                data = snapshot.to_dict()
                data["id"] = snapshot.id
                results.append(self.model_schema(**data))
        return results

    async def add_player_to_game(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, game_id: str, player_uid: str
    ) -> bool:
        """
        Adds a player's UID to the game's player_uids list.
        This is an atomic array-union operation.
        """
        game_ref = db.collection(self.collection_name).document(game_id)
        from google.cloud.firestore import ArrayUnion # Import for array operation

        try:
            await game_ref.update({"player_uids": ArrayUnion([player_uid])})
            return True
        except Exception as e:
            print(f"Error adding player {player_uid} to game {game_id}: {e}")
            return False

    async def remove_player_from_game(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, game_id: str, player_uid: str
    ) -> bool:
        """
        Removes a player's UID from the game's player_uids list.
        This is an atomic array-remove operation.
        """
        game_ref = db.collection(self.collection_name).document(game_id)
        from google.cloud.firestore import ArrayRemove # Import for array operation

        try:
            await game_ref.update({"player_uids": ArrayRemove([player_uid])})
            return True
        except Exception as e:
            print(f"Error removing player {player_uid} from game {game_id}: {e}")
            return False
            
    async def update_game_status(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, game_id: str, status: str
    ) -> Optional[Dict[str, Any]]:
        """
        Updates the game's status.
        """
        return await super().update(db, doc_id=game_id, obj_in={"game_status": status, "updated_at": datetime.utcnow()})

    # Additional game-specific methods can be added here, for example:
    # - Get active games
    # - Get games a specific player_uid is part of (more complex query or denormalization)


# Instantiate the CRUDGame class
crud_game = CRUDGame(collection_name=GAME_COLLECTION, model_schema=GameInDB)