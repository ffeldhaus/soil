============================= test session starts ==============================
platform linux -- Python 3.13.3, pytest-8.3.5, pluggy-1.6.0
rootdir: /app/backend
configfile: pyproject.toml
plugins: asyncio-1.0.0, cov-6.1.1, anyio-4.9.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 89 items

tests/crud/test_crud_admin.py FF.FFFF.F...                               [ 13%]
tests/crud/test_crud_game.py FF.F.F.F....F...                            [ 31%]
tests/crud/test_crud_player.py FF.FFFFFFFFF..                            [ 47%]
tests/crud/test_crud_result.py FF.FFFF                                   [ 55%]
tests/crud/test_crud_round.py F..F.F.....                                [ 67%]
tests/game_logic/test_ai_player.py ..........                            [ 78%]
tests/game_logic/test_calculation_engine.py ..                           [ 80%]
tests/game_logic/test_decision_impacts.py .................              [100%]

=================================== FAILURES ===================================
__________________________ test_create_admin_with_uid __________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3b01c57b10>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891356751520'>
admin_create_obj = AdminCreate(email='admin@example.com', user_type=<UserType.ADMIN: 'admin'>, is_active=True, first_name='Test', last_name='Admin', institution='Test University', password='securepassword123')
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891356756224'>

    @pytest.mark.asyncio
    async def test_create_admin_with_uid(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_create_obj: AdminCreate,
        mock_doc_snapshot: MagicMock # Used to mock the .get() call after .set()
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        # document(ADMIN_UID) is already configured by mock_doc_snapshot to return it on .get()
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        # Patch 'get_password_hash' and 'datetime' in 'app.crud.crud_admin'
        # This assumes 'from datetime import datetime, timezone' exists in app.crud.crud_admin
        with patch("app.crud.crud_admin.get_password_hash", return_value="hashed_password_example_from_get_password_hash") as mock_hash, \
             patch("app.crud.crud_admin.datetime") as mock_datetime_module:
            mock_datetime_module.now.return_value = FIXED_DATETIME_NOW
            mock_datetime_module.utcnow.return_value = FIXED_DATETIME_NOW # If utcnow is used

            # Act
            created_admin_dict = await crud_admin_instance.create_with_uid(
                db=mock_firestore_db, uid=ADMIN_UID, obj_in=admin_create_obj
            )

        # Assert
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        # Patch 'get_password_hash' and 'datetime' in 'app.crud.crud_admin'
        # This assumes 'from datetime import datetime, timezone' exists in app.crud.crud_admin
        with patch("app.crud.crud_admin.get_password_hash", return_value="hashed_password_example_from_get_password_hash") as mock_hash, \
             patch("app.crud.crud_admin.datetime") as mock_datetime_module:
            mock_datetime_module.now.return_value = FIXED_DATETIME_NOW # Used for created_at and updated_at
            # mock_datetime_module.utcnow.return_value = FIXED_DATETIME_NOW # If utcnow is used by crud

            # Act
            # The create_with_uid method will call .set() and then .get() on the doc_ref.
            # The mock_doc_snapshot fixture is configured to be returned by .get() on ADMIN_UID.
            # Its .to_dict() method will provide the data for created_admin_dict.
            # The ADMIN_IN_DB_DICT_BASE (used by mock_doc_snapshot) has full_name="Test Admin"
            # and timestamps are set by the fixture to FIXED_DATETIME_NOW.
            created_admin_dict = await crud_admin_instance.create_with_uid(
                db=mock_firestore_db, uid=ADMIN_UID, obj_in=admin_create_obj
            )

        # Assert
        assert created_admin_dict is not None, "create_with_uid should return a dictionary."

        # Ensure the dictionary from Firestore can be parsed into AdminInDB model
        # This also validates that the structure matches AdminInDB, including timestamps.
        created_admin = AdminInDB(**created_admin_dict)

        # 1. Check what was passed to Firestore's .set() method on the specific mock_doc_ref
>       mock_doc_ref_for_admin_uid.set.assert_called_once()

tests/crud/test_crud_admin.py:169:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.set' id='139891356753872'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'set' to have been called once. Called 2 times.
E           Calls: [call({'email': 'admin@example.com', 'is_active': True, 'first_name': 'Test', 'last_name': 'Admin', 'institution': 'Test University', 'hashed_password': 'hashed_password_example_from_get_password_hash', 'user_type': 'admin', 'is_superuser': True, 'created_at': datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc), 'updated_at': datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc), 'full_name': 'Test Admin'}),
E            call({'email': 'admin@example.com', 'is_active': True, 'first_name': 'Test', 'last_name': 'Admin', 'institution': 'Test University', 'hashed_password': 'hashed_password_example_from_get_password_hash', 'user_type': 'admin', 'is_superuser': True, 'created_at': datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc), 'updated_at': datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc), 'full_name': 'Test Admin'})].

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:958: AssertionError
________________________ test_get_admin_by_email_found _________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3afeba7d90>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891356761600'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891352195760'>

    @pytest.mark.asyncio
    async def test_get_admin_by_email_found(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # This snapshot is configured with ADMIN_EMAIL
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        # Setup for .where().limit().stream()
        # This complex mocking is to ensure the chained calls .where().limit().stream() work as expected.
        mock_query_obj = AsyncMock() # This will be returned by .where()
        mock_limit_query_obj = AsyncMock() # This will be returned by .limit()

        async def stream_results_generator(*args, **kwargs): # The async generator for .stream()
            yield mock_doc_snapshot

        mock_limit_query_obj.stream = stream_results_generator # .stream() method returns the generator
        mock_query_obj.limit = MagicMock(return_value=mock_limit_query_obj) # .limit() method returns mock_limit_query_obj
        mock_collection_ref.where = MagicMock(return_value=mock_query_obj) # .where() method returns mock_query_obj

        # Act
        admin = await crud_admin_instance.get_by_email(db=mock_firestore_db, email=ADMIN_EMAIL)

        # Assert
        assert admin is not None
        # mock_doc_snapshot data is based on ADMIN_IN_DB_DICT_BASE and fixture timestamps
        assert admin.uid == ADMIN_UID
>       assert admin.id == ADMIN_UID # From ADMIN_IN_DB_DICT_BASE

tests/crud/test_crud_admin.py:235:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = AdminInDB(email='admin@example.com', user_type='admin', is_active=True, first_name='Test', last_name='Admin', institut...1, 12, 0, tzinfo=datetime.timezone.utc), updated_at=datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc))
item = 'id'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'AdminInDB' object has no attribute 'id'. Did you mean: 'uid'?

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
______________________________ test_update_admin _______________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3afe98cb00>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891352205504'>
admin_update_obj = AdminUpdate(email='updated.admin@example.com', first_name='UpdatedTest', last_name='AdminUser', institution='Updated University', is_active=None, password=None)
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891354897440'>

    @pytest.mark.asyncio
    async def test_update_admin(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_update_obj: AdminUpdate,
        mock_doc_snapshot: MagicMock # Represents state *before* update for the first .get()
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        # Data for snapshot returned *after* update.
        # This should reflect the changes made by admin_update_obj.
        # Original created_at, user_type, and hashed_password should remain.
        original_doc_data_before_update = mock_doc_snapshot.to_dict() # Data from ADMIN_IN_DB_DICT_BASE + timestamps
        expected_full_name_after_update = f"{admin_update_obj.first_name} {admin_update_obj.last_name}"

        data_after_update_dict = {
            **original_doc_data_before_update, # Start with existing data
            "first_name": admin_update_obj.first_name,
            "last_name": admin_update_obj.last_name,
            "full_name": expected_full_name_after_update,
            "email": admin_update_obj.email,
            "institution": admin_update_obj.institution,
            "updated_at": FIXED_DATETIME_LATER, # This will be set by the update method in CRUDAdmin
            # Fields that should NOT change:
            "created_at": original_doc_data_before_update["created_at"],
            "hashed_password": original_doc_data_before_update["hashed_password"],
            "user_type": original_doc_data_before_update["user_type"],
            "is_superuser": original_doc_data_before_update["is_superuser"],
            # is_active can be changed by AdminUpdate, so if it's in admin_update_obj, it should be here
            "is_active": admin_update_obj.is_active if admin_update_obj.is_active is not None else original_doc_data_before_update["is_active"],
        }

        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = data_after_update_dict
        mock_snapshot_after_update.id = ADMIN_UID

        # CRUDBase.update calls doc_ref.update() then doc_ref.get().
        # The mock_doc_snapshot fixture (passed to this test) represents the state *before* this update.
        # It's used by CRUDBase if it internally calls .get() before .update() (which it doesn't explicitly).
        # More importantly, the .get() *after* the .update() call needs to return the new state.
        mock_doc_ref_for_admin_uid.get = AsyncMock(return_value=mock_snapshot_after_update)


        # Patch datetime.now() in app.crud.crud_admin.py as it's used by CRUDAdmin.update
        with patch("app.crud.crud_admin.datetime") as mock_datetime_crud_admin_module:
            # Mock datetime.now(timezone.utc) specifically if that's what's used.
            # If it's just datetime.now(), this is fine.
            mock_datetime_crud_admin_module.now.return_value = FIXED_DATETIME_LATER # Time of update

            # Act
            updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=ADMIN_UID, obj_in=admin_update_obj
            )

        # Assert
        assert updated_admin_dict is not None, "Update should return the updated admin dictionary."
        updated_admin = AdminInDB(**updated_admin_dict)

        # 1. Check what was passed to Firestore's .update() method
        mock_doc_ref_for_admin_uid.update.assert_called_once()
        args_to_update, _ = mock_doc_ref_for_admin_uid.update.call_args
        actual_update_payload = args_to_update[0]

        assert "password" not in actual_update_payload, "Plain password should not be in Firestore update payload."
        assert "hashed_password" not in actual_update_payload, "Hashed password should not be sent directly in this payload."
        assert actual_update_payload["first_name"] == admin_update_obj.first_name
        assert actual_update_payload["last_name"] == admin_update_obj.last_name
        assert actual_update_payload["email"] == admin_update_obj.email
        assert actual_update_payload["institution"] == admin_update_obj.institution
>       assert actual_update_payload["full_name"] == expected_full_name_after_update
E       KeyError: 'full_name'

tests/crud/test_crud_admin.py:341: KeyError
______________________ test_update_admin_ignores_password ______________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3afe827e30>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891352200800'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891354899792'>

    @pytest.mark.asyncio
    async def test_update_admin_ignores_password(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # Represents current state in DB (before this specific test's update)
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        original_doc_data = mock_doc_snapshot.to_dict()
        original_hashed_password = original_doc_data["hashed_password"]
        original_created_at = original_doc_data["created_at"]
        original_user_type_str = original_doc_data["user_type"] # e.g., "admin"
        original_is_superuser = original_doc_data["is_superuser"]
        original_is_active = original_doc_data["is_active"]


        update_payload_with_password = AdminUpdate(
            first_name="PasswordTestFirstName", # Changed field
            # last_name, email, institution will be None, so they shouldn't be in payload unless model_dump(exclude_none=False)
            # CRUDAdmin.update uses obj_in.model_dump(exclude_unset=True, exclude_none=True)
            # So only first_name and password (which is then deleted) will be in update_data from AdminUpdate.
            password="newfakepassword123" # This should be ignored by CRUDAdmin.update logic
        )

        # Data for snapshot returned *after* this specific update attempt.
        # Only first_name and updated_at should change. Password-related fields remain untouched.
        data_after_update_attempt_dict = {
            **original_doc_data, # Start with existing data
            "first_name": update_payload_with_password.first_name,
            # full_name should also update if first_name changes and last_name is present
            "full_name": f"{update_payload_with_password.first_name} {original_doc_data['last_name']}",
            "updated_at": FIXED_DATETIME_LATER, # This will be set by CRUDAdmin.update
            # Fields that should NOT change:
            "hashed_password": original_hashed_password,
            "created_at": original_created_at,
            "user_type": original_user_type_str,
            "email": original_doc_data["email"], # Unchanged as not in update_payload_with_password
            "last_name": original_doc_data["last_name"], # Unchanged
            "institution": original_doc_data["institution"], # Unchanged
            "is_superuser": original_is_superuser, # Unchanged
            "is_active": original_is_active, # Unchanged
        }
        mock_snapshot_after_update_attempt = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update_attempt.exists = True
        mock_snapshot_after_update_attempt.to_dict.return_value = data_after_update_attempt_dict
        mock_snapshot_after_update_attempt.id = ADMIN_UID

        # Configure .get() on the specific doc ref to return the state *after* the update call
        mock_doc_ref_for_admin_uid.get = AsyncMock(return_value=mock_snapshot_after_update_attempt)

        with patch("app.crud.crud_admin.datetime") as mock_datetime_module:
            mock_datetime_module.now.return_value = FIXED_DATETIME_LATER # Time of update

            # Act
            updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=ADMIN_UID, obj_in=update_payload_with_password
            )

        # Assert
        assert updated_admin_dict is not None, "Update should return a dictionary even if only timestamps change."
        updated_admin = AdminInDB(**updated_admin_dict)

        # 1. Check what was passed to Firestore's .update() method
        mock_doc_ref_for_admin_uid.update.assert_called_once()
        args_to_update, _ = mock_doc_ref_for_admin_uid.update.call_args
        actual_update_payload = args_to_update[0]

        assert "password" not in actual_update_payload, "Plain password should NOT be in Firestore update payload."
        assert "hashed_password" not in actual_update_payload, "Hashed password should NOT be in this update payload."
        assert actual_update_payload["first_name"] == update_payload_with_password.first_name
        assert "last_name" not in actual_update_payload # Was not in AdminUpdate with exclude_none=True
        assert "email" not in actual_update_payload # Was not in AdminUpdate
>       assert actual_update_payload["full_name"] == f"{update_payload_with_password.first_name} {original_doc_data['last_name']}"
E       KeyError: 'full_name'

tests/crud/test_crud_admin.py:436: KeyError
________________________ test_update_admin_non_existent ________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3afe8849e0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891354900464'>
admin_update_obj = AdminUpdate(email='updated.admin@example.com', first_name='UpdatedTest', last_name='AdminUser', institution='Updated University', is_active=None, password=None)
mock_doc_snapshot_non_existent = <MagicMock spec='DocumentSnapshot' id='139891354907856'>

    @pytest.mark.asyncio
    async def test_update_admin_non_existent(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_update_obj: AdminUpdate,
        mock_doc_snapshot_non_existent: MagicMock # Configured for "non-existent-admin-uid"
    ):
        # Arrange
        # mock_firestore_db.collection().document("non-existent-admin-uid").get is already mocked by the fixture

        # Act
        # No need to patch datetime if .get() returns non-existent, as .update won't be called.
        updated_admin_dict = await crud_admin_instance.update(
            db=mock_firestore_db, doc_id="non-existent-admin-uid", obj_in=admin_update_obj
        )

        # Assert
        assert updated_admin_dict is None
>       mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS).document("non-existent-admin-uid").update.assert_not_called()

tests/crud/test_crud_admin.py:468:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.update' id='139891354906176'>

    def assert_not_called(self):
        """assert that the mock was never called.
        """
        if self.call_count != 0:
            msg = ("Expected '%s' to not have been called. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'update' to not have been called. Called 1 times.
E           Calls: [call({'email': 'updated.admin@example.com', 'first_name': 'UpdatedTest', 'last_name': 'AdminUser', 'institution': 'Updated University', 'updated_at': datetime.datetime(2025, 5, 30, 22, 44, 51, 77651, tzinfo=datetime.timezone.utc)})].

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:940: AssertionError
__________________________ test_get_admin_by_id_found __________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3afea1a7a0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891352199120'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891352205168'>

    @pytest.mark.asyncio
    async def test_get_admin_by_id_found(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # Already configured for ADMIN_UID and returns data
    ):
        # Act
        admin_dict = await crud_admin_instance.get(db=mock_firestore_db, doc_id=ADMIN_UID)

        # Assert
        assert admin_dict is not None
>       admin = AdminInDB(**admin_dict) # Uses data from mock_doc_snapshot.to_dict()
E       TypeError: app.schemas.admin.AdminInDB() argument after ** must be a mapping, not AdminInDB

tests/crud/test_crud_admin.py:482: TypeError
____________________________ test_get_multi_admins _____________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f3afe951650>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891352198784'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891356756896'>

    @pytest.mark.asyncio
    async def test_get_multi_admins(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # Snapshot for the first admin (ADMIN_UID, from ADMIN_IN_DB_DICT_BASE)
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)

        # Data for a second admin
        other_admin_id = "other-admin-uid"
        other_admin_email = "other.admin@example.com"
        other_admin_data_dict = {
            **ADMIN_IN_DB_DICT_BASE, # Start with base and override
            "uid": other_admin_id,
            "id": other_admin_id,
            "email": other_admin_email,
            "first_name": "OtherFirst",
            "last_name": "OtherLast",
            "full_name": "OtherFirst OtherLast",
            "institution": "Other University",
            # Timestamps can be different or same, using same for simplicity here
            "created_at": FIXED_DATETIME_NOW,
            "updated_at": FIXED_DATETIME_NOW,
            "user_type": UserType.ADMIN.value, # Stored as string
        }
        mock_doc_snapshot_other = MagicMock(spec=DocumentSnapshot)
        mock_doc_snapshot_other.exists = True
        mock_doc_snapshot_other.to_dict.return_value = other_admin_data_dict
        mock_doc_snapshot_other.id = other_admin_id

        # --- Test 1: Get multiple admins with default limit (expect both) ---
        async def stream_two_results(*args, **kwargs):
            yield mock_doc_snapshot # Represents ADMIN_UID data
            yield mock_doc_snapshot_other

        # Configure the mock for collection_ref.limit().stream() chain
        # CRUDBase.get_multi calls collection.limit(limit + skip).stream()
        # Default limit is 100, skip is 0. limit(100 + 0) = limit(100)
        mock_stream_obj_two_results = AsyncMock() # Object returned by .limit()
        mock_stream_obj_two_results.stream = stream_two_results # .stream() is the async generator
        mock_collection_ref.limit = MagicMock(return_value=mock_stream_obj_two_results)

        admins_list_two = await crud_admin_instance.get_multi(db=mock_firestore_db, limit=10) # Default skip=0

        assert len(admins_list_two) == 2
        mock_collection_ref.limit.assert_called_with(10 + 0) # limit + skip

        admin1 = admins_list_two[0]
        assert admin1.uid == ADMIN_UID
        assert admin1.email == ADMIN_IN_DB_DICT_BASE["email"]
        assert admin1.user_type == UserType.ADMIN
        assert admin1.created_at == FIXED_DATETIME_NOW
        assert admin1.updated_at == FIXED_DATETIME_NOW
>       assert admin1.full_name == ADMIN_IN_DB_DICT_BASE["full_name"]

tests/crud/test_crud_admin.py:564:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = AdminInDB(email='admin@example.com', user_type='admin', is_active=True, first_name='Test', last_name='Admin', institut...1, 12, 0, tzinfo=datetime.timezone.utc), updated_at=datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc))
item = 'full_name'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'AdminInDB' object has no attribute 'full_name'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
_________________________ test_create_game_with_admin __________________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7f3b01c56490>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891356754208'>
game_create_obj = GameCreate(name='Test Game Alpha', number_of_rounds=5, max_players=2, requested_player_slots=1, ai_player_count=0)
mock_game_rules_sequences_fixture = (<MagicMock name='generate_weather_sequence' id='139891356751856'>, <MagicMock name='generate_vermin_sequence' id='139891356755552'>)

    @pytest.mark.asyncio
    async def test_create_game_with_admin(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        game_create_obj: GameCreate,
        mock_game_rules_sequences_fixture # Autouse fixture
    ):
        mock_weather_gen, mock_vermin_gen = mock_game_rules_sequences_fixture

        # Expected data for GameInDB instantiation after creation
        # This data is what the mocked CRUDBase.create() should return
        expected_game_dict_from_base_create = {
            "id": TEST_GAME_ID, # Assume CRUDBase.create adds this 'id'
            "uid": TEST_GAME_ID, # And 'uid' if schema expects it
            "name": game_create_obj.name, "adminId": ADMIN_ID, # Use alias 'adminId'
            "number_of_rounds": game_create_obj.number_of_rounds,
            "max_players": game_create_obj.max_players,
            "weather_sequence": DEFAULT_WEATHER_SEQ, "vermin_sequence": DEFAULT_VERMIN_SEQ,
            "player_uids": [], "game_status": GameStatus.PENDING.value,
            "current_round_number": 0, "game_stage": GameStage.INITIAL_SETUP.value,
            "created_at": FIXED_DATETIME_NOW_GAME, # Expecting datetime objects now from CRUDBase
            "updated_at": FIXED_DATETIME_NOW_GAME,
            "ai_player_strategies": {}
        }

        # Mock CRUDBase.create behavior specifically for this test path
        # CRUDGame.create_with_admin calls super().create()
        with patch("app.crud.base.CRUDBase.create", new_callable=AsyncMock) as mock_crudbase_create:
            # CRUDBase.create is expected to return a dict that can initialize the Pydantic model
            mock_crudbase_create.return_value = expected_game_dict_from_base_create

            created_game_dict_result = await crud_game_instance.create_with_admin(
                db=mock_firestore_db, obj_in=game_create_obj, admin_id=ADMIN_ID
            )

        assert created_game_dict_result is not None
        # Ensure the dict returned by create_with_admin can initialize GameInDB
        created_game = GameInDB(**created_game_dict_result)

        mock_weather_gen.assert_called_once_with(game_create_obj.number_of_rounds)
        mock_vermin_gen.assert_called_once_with(game_create_obj.number_of_rounds)

        mock_crudbase_create.assert_called_once()
        # Check the 'obj_in' passed to CRUDBase.create (this is 'game_data' from CRUDGame.create_with_admin)
        passed_obj_to_crudbase = mock_crudbase_create.call_args[1]['obj_in']

        # Assertions for fields from GameCreate schema
        assert passed_obj_to_crudbase["name"] == game_create_obj.name
        assert passed_obj_to_crudbase["number_of_rounds"] == game_create_obj.number_of_rounds
        assert passed_obj_to_crudbase["max_players"] == game_create_obj.max_players
        # requested_player_slots is part of GameCreate but might not be directly stored or used later in GameInDB
        # assert passed_obj_to_crudbase["requested_player_slots"] == game_create_obj.requested_player_slots

        # Assertions for fields added/set by CRUDGame.create_with_admin
        assert passed_obj_to_crudbase["admin_id"] == ADMIN_ID
        assert passed_obj_to_crudbase["current_round_number"] == 0
        assert passed_obj_to_crudbase["game_status"] == GameStatus.PENDING.value # Stored as string value
        assert passed_obj_to_crudbase["player_uids"] == []
        assert passed_obj_to_crudbase["weather_sequence"] == DEFAULT_WEATHER_SEQ
        assert passed_obj_to_crudbase["vermin_sequence"] == DEFAULT_VERMIN_SEQ
        # Timestamps (created_at, updated_at) are handled by CRUDBase.create or Firestore,
        # so they are not expected in passed_obj_to_crudbase here.
        # ai_player_strategies is not set by create_with_admin, defaults to {} in Pydantic if not provided by CRUDBase.create mock

        # Assertions for the returned GameInDB object (created_game)
        # This object is initialized from 'expected_game_dict_from_base_create'
        assert created_game.id == TEST_GAME_ID
>       assert created_game.uid == TEST_GAME_ID

tests/crud/test_crud_game.py:164:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = GameInDB(name='Test Game Alpha', number_of_rounds=5, max_players=2, id='test-game-id-123', admin_id='admin-user-id-abc...e=['Normal', 'Drought', 'Normal'], vermin_sequence=['None', 'Aphids', 'None'], player_uids=[], ai_player_strategies={})
item = 'uid'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'GameInDB' object has no attribute 'uid'. Did you mean: 'id'?

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
_______________________ test_get_games_by_admin_id_found _______________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7f3afe979950>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891354896096'>
mock_game_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891353495472'>

    @pytest.mark.asyncio
    async def test_get_games_by_admin_id_found(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_game_doc_snapshot: MagicMock # Specific snapshot for a game
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES)
        mock_query = AsyncMock(spec=AsyncQuery) # This is the object after .where().limit() etc.
        mock_collection_ref.where.return_value = mock_query # Assuming where returns the final query obj for simplicity here

        async def stream_results_gen(*args, **kwargs):
            yield mock_game_doc_snapshot

        # query.stream is a method that returns an async generator
        mock_query.stream = MagicMock(return_value=stream_results_gen())

        games_list = await crud_game_instance.get_games_by_admin_id(db=mock_firestore_db, admin_id=ADMIN_ID)

>       mock_collection_ref.where.assert_called_once_with("admin_id", "==", ADMIN_ID)

tests/crud/test_crud_game.py:198:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='139891353493456'>
args = ('admin_id', '==', 'admin-user-id-abc'), kwargs = {}
expected = call('admin_id', '==', 'admin-user-id-abc')
actual = call(field='admin_id', op_string='==', value='admin-user-id-abc')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f3afe860cc0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('admin_id', '==', 'admin-user-id-abc')
E             Actual: where(field='admin_id', op_string='==', value='admin-user-id-abc')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
_______________________ test_add_player_to_game_success ________________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7f3afe98cb00>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353496144'>
mock_array_union_class = <MagicMock name='ArrayUnion' id='139891354909872'>

    @pytest.mark.asyncio
    async def test_add_player_to_game_success(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_array_union_class # From conftest.py (patches google.cloud.firestore.ArrayUnion)
    ):
        game_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES).document(TEST_GAME_ID)
        # game_doc_ref.update is an AsyncMock from mock_firestore_db in conftest

        result = await crud_game_instance.add_player_to_game(
            db=mock_firestore_db, game_id=TEST_GAME_ID, player_uid=PLAYER_UID_1
        )
        assert result is True
        # mock_array_union_class is the MagicMock for the class ArrayUnion
        # Its return_value is what's passed to update
        mock_array_union_class.assert_called_once_with([PLAYER_UID_1])
>       game_doc_ref.update.assert_called_once_with({"player_uids": mock_array_union_class.return_value})

tests/crud/test_crud_game.py:256:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.update' id='139891353491776'>
args = ({'player_uids': <MagicMock name='ArrayUnion()' id='139891354896768'>},)
kwargs = {}
expected = call({'player_uids': <MagicMock name='ArrayUnion()' id='139891354896768'>})
actual = call({'player_uids': ['player-uid-xyz']})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f3afe7c8cc0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update({'player_uids': <MagicMock name='ArrayUnion()' id='139891354896768'>})
E             Actual: update({'player_uids': ['player-uid-xyz']})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
_____________________ test_remove_player_from_game_success _____________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7f3afea1b240>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891356758912'>
mock_array_remove_class = <MagicMock name='ArrayRemove' id='139891352202816'>

    @pytest.mark.asyncio
    async def test_remove_player_from_game_success(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_array_remove_class # From conftest.py
    ):
        game_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES).document(TEST_GAME_ID)

        result = await crud_game_instance.remove_player_from_game(
            db=mock_firestore_db, game_id=TEST_GAME_ID, player_uid=PLAYER_UID_1
        )
        assert result is True
        mock_array_remove_class.assert_called_once_with([PLAYER_UID_1])
>       game_doc_ref.update.assert_called_once_with({"player_uids": mock_array_remove_class.return_value})

tests/crud/test_crud_game.py:290:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.update' id='139891352194416'>
args = ({'player_uids': <MagicMock name='ArrayRemove()' id='139891352202480'>},)
kwargs = {}
expected = call({'player_uids': <MagicMock name='ArrayRemove()' id='139891352202480'>})
actual = call({'player_uids': ['player-uid-xyz']})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f3afe716480>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update({'player_uids': <MagicMock name='ArrayRemove()' id='139891352202480'>})
E             Actual: update({'player_uids': ['player-uid-xyz']})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
___________________________ test_update_game_status ____________________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7f3afe950850>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891349376368'>

    @pytest.mark.asyncio
    async def test_update_game_status(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
    ):
        new_status = GameStatus.ACTIVE
        game_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES).document(TEST_GAME_ID)

        # Data that will be returned by the snapshot after the update
        # This is used by CRUDBase.update to construct the returned Pydantic model
        # It should come from the generic doc snapshot mock defined in conftest's mock_firestore_db
        # but overridden for the specific game ID and with updated status/timestamp.

        # Get the generic snapshot data from the conftest fixture's setup
        # (This is a bit complex, ideally the fixture provides a way to get this base data)
        # For simplicity, we'll redefine what the snapshot for THIS test should return.
        updated_snapshot_data = {
            **BASE_GAME_IN_DB_DICT, # Base structure, uses adminId
            "id": TEST_GAME_ID, "uid": TEST_GAME_ID, # Ensure correct ID
            "game_status": new_status.value,
            "updated_at": FIXED_DATETIME_LATER_GAME.isoformat(), # CRUDBase.update calls doc_ref.get()
            "created_at": FIXED_DATETIME_NOW_GAME.isoformat() # Original created_at
        }
        # Convert to datetime objects for Pydantic model if model expects them
        expected_return_dict_for_pydantic = {
            **updated_snapshot_data,
            "created_at": FIXED_DATETIME_NOW_GAME,
            "updated_at": FIXED_DATETIME_LATER_GAME,
        }

        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = updated_snapshot_data
        mock_snapshot_after_update.id = TEST_GAME_ID
        game_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_update) # After .update() in CRUDBase

        # Patch datetime.now used within CRUDGame.update_game_status
        with patch("app.crud.crud_game.datetime") as mock_datetime_crud_game:
            # This datetime is for the 'updated_at' set by update_game_status itself
            mock_datetime_crud_game.now.return_value = FIXED_DATETIME_LATER_GAME
            # If CRUDBase.update also sets its own updated_at, that would need patching too
            # but current CRUDBase.update doesn't add timestamps to the dict it sends to Firestore.
            # It relies on the snapshot returned by .get() for the final data.

            updated_game_dict_result = await crud_game_instance.update_game_status(
                db=mock_firestore_db, game_id=TEST_GAME_ID, status=new_status # Pass enum directly
            )

        assert updated_game_dict_result is not None
        # The dict returned from CRUDBase.update is based on mock_snapshot_after_update.to_dict()
        # Pydantic model expects datetime objects, to_dict() returns ISO strings.
        # CRUDBase.get and by extension CRUDBase.update (which calls get) should handle this conversion
        # if the Pydantic model fields are `datetime`.
        # So, updated_game_dict_result should have datetime objects if CRUDBase converts them.
        # The `mock_firestore_db` in conftest for `generic_doc_snapshot_data` returns datetime objects.
        # Let's assume `updated_game_dict_result` is the dict from `to_dict()` (ISO strings)
        # and Pydantic parsing handles it.
        # However, CRUDBase.update returns snapshot.to_dict() which then is used to make the model.
        # The provided `generic_doc_snapshot_data` in conftest has datetime objects for created_at/updated_at.
        # This needs to be consistent. Let's assume `CRUDBase` returns a dict ready for Pydantic.
        # The `expected_return_dict_for_pydantic` has datetime objects.
        # The actual `game_doc_ref.update` payload will have `updated_at` from `update_game_status`.

        # Check the payload sent to Firestore via CRUDBase.update
        # The obj_in for super().update in update_game_status is {"game_status": status, "updated_at": datetime.utcnow()}
        game_doc_ref.update.assert_called_once()
        update_call_args = game_doc_ref.update.call_args[0][0]
        assert update_call_args["game_status"] == new_status.value
>       assert update_call_args["updated_at"] == FIXED_DATETIME_LATER_GAME # This is from the patched datetime.utcnow()
E       AssertionError: assert <MagicMock name='datetime.utcnow()' id='139891349718080'> == datetime.datetime(2023, 1, 1, 13, 0, tzinfo=datetime.timezone.utc)

tests/crud/test_crud_game.py:378: AssertionError
__________________________ test_get_game_by_id_found ___________________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7f3afe8f2970>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891354901808'>
mock_game_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891353491776'>

    @pytest.mark.asyncio
    async def test_get_game_by_id_found(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient,
        mock_game_doc_snapshot: MagicMock
    ):
        # mock_game_doc_snapshot is configured by its fixture
        game_dict = await crud_game_instance.get(db=mock_firestore_db, doc_id=TEST_GAME_ID)
        assert game_dict is not None
>       game = GameInDB(**game_dict)
E       TypeError: app.schemas.game.GameInDB() argument after ** must be a mapping, not GameInDB

tests/crud/test_crud_game.py:447: TypeError
_________________________ test_create_player_with_uid __________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3b01c57b10>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891349383424'>
player_create_obj = PlayerCreate(email='player.test@example.com', user_type=<UserType.PLAYER: 'player'>, is_active=True, username='TestPla...ha', game_id='test-game-id-for-player-tests', player_number=1, is_ai=False, ai_strategy=None, password='playerpass789')

    @pytest.mark.asyncio
    async def test_create_player_with_uid(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        player_create_obj: PlayerCreate
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)

        # Data for the snapshot that .get() will return after .set()
        # This is what CRUDBase.create_with_uid will use to build the returned PlayerInDB
        expected_player_dict_from_get = {
            **BASE_PLAYER_IN_DB_DICT, # Start with base, override as needed
            "temp_password_hash": "hashed_temp_password_from_patch", # This is set by create_with_uid
            # created_at/updated_at will be FIXED_DATETIME_NOW_PLAYER due to patching datetime.now
        }
        # snapshot.to_dict() returns ISO strings for datetimes
        snap_dict_return = expected_player_dict_from_get.copy()
        snap_dict_return["created_at"] = FIXED_DATETIME_NOW_PLAYER.isoformat()
        snap_dict_return["updated_at"] = FIXED_DATETIME_NOW_PLAYER.isoformat()

        mock_snapshot_after_set = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_set.exists = True
        mock_snapshot_after_set.to_dict.return_value = snap_dict_return
        mock_snapshot_after_set.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_set) # Used by CRUDBase after set

        # Patch get_password_hash and datetime.now in app.crud.crud_player
        with patch("app.crud.crud_player.get_password_hash", return_value="hashed_temp_password_from_patch") as mock_hash, \
             patch("app.crud.crud_player.datetime") as mock_dt_crud_player: # For created_at/updated_at in Player
            mock_dt_crud_player.now.return_value = FIXED_DATETIME_NOW_PLAYER

            created_player_dict_result = await crud_player_instance.create_with_uid(
                db=mock_firestore_db, uid=PLAYER_UID, obj_in=player_create_obj
            )

        assert created_player_dict_result is not None
        created_player = PlayerInDB(**created_player_dict_result)

        mock_hash.assert_called_once_with(player_create_obj.password)

        # Check data passed to Firestore .set()
        player_doc_ref.set.assert_called_once()
        actual_set_data = player_doc_ref.set.call_args[0][0]

>       assert actual_set_data["uid"] == PLAYER_UID
E       KeyError: 'uid'

tests/crud/test_crud_player.py:136: KeyError
________________________ test_get_player_by_email_found ________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe978e10>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891349262352'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891349273776'>

    @pytest.mark.asyncio
    async def test_get_player_by_email_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock # Specific player snapshot
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query

        async def stream_results_gen(*args, **kwargs): yield mock_player_doc_snapshot
        # query.limit(1).stream() -> query.limit() returns a new query object.
        # So, the final object that .stream() is called on needs to have .stream mocked.
        mock_limit_query = AsyncMock(spec=AsyncQuery)
        mock_query.limit = MagicMock(return_value=mock_limit_query)
        mock_limit_query.stream = MagicMock(return_value=stream_results_gen())


        player_dict = await crud_player_instance.get_by_email(db=mock_firestore_db, email=PLAYER_EMAIL)
        assert player_dict is not None
>       player = PlayerInDB(**player_dict) # Pydantic parses ISO strings from snapshot
E       TypeError: app.schemas.player.PlayerInDB() argument after ** must be a mapping, not PlayerInDB

tests/crud/test_crud_player.py:199: TypeError
______________________________ test_update_player ______________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe98cc30>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891349077168'>
player_update_obj = PlayerUpdate(username='TestPlayerAlphaUpdated', password=None, is_active=False)
mock_player_doc_snapshot_data = {'ai_strategy': None, 'created_at': '2023-01-02T10:00:00+00:00', 'current_capital': 0.0, 'email': 'player.test@example.com', ...}

    @pytest.mark.asyncio
    async def test_update_player(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        player_update_obj: PlayerUpdate,
        mock_player_doc_snapshot_data: dict # Base data for the player
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)

        # Data for snapshot *after* update
        data_after_update_dict = {
            **mock_player_doc_snapshot_data, # Contains original created_at, email etc. as ISO strings
            "username": player_update_obj.username,
            "is_active": player_update_obj.is_active,
            "updated_at": FIXED_DATETIME_LATER_PLAYER.isoformat() # Updated timestamp as ISO string
        }
        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = data_after_update_dict
        mock_snapshot_after_update.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_update) # CRUDBase.update calls .get()

        # Patch datetime.now() in app.crud.crud_player (used by CRUDPlayer.update)
        # and app.crud.base (if it were to also set updated_at, though current CRUDBase does not)
        with patch("app.crud.crud_player.datetime") as mock_dt_player, \
>            patch("app.crud.base.datetime") as mock_dt_base: # CRUDBase might use it in future

tests/crud/test_crud_player.py:267:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3afe936430>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.crud.base' from '/app/backend/app/crud/base.py'> does not have the attribute 'datetime'

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:1467: AttributeError
_____________________ test_update_player_ignores_password ______________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe3668d0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353489088'>
mock_player_doc_snapshot_data = {'ai_strategy': None, 'created_at': '2023-01-02T10:00:00+00:00', 'current_capital': 0.0, 'email': 'player.test@example.com', ...}

    @pytest.mark.asyncio
    async def test_update_player_ignores_password(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient,
        mock_player_doc_snapshot_data: dict # Represents current state in DB
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)
        original_temp_hash = mock_player_doc_snapshot_data["temp_password_hash"]

        update_with_password = PlayerUpdate(
            username="PlayerIgnoresPass",
            password="newfakepassword123" # This should be ignored
        )

        # Data for snapshot returned *after* this specific update attempt
        data_after_update_attempt_dict = {
            **mock_player_doc_snapshot_data, # Start with existing data (ISO dates)
            "username": update_with_password.username,
            "updated_at": FIXED_DATETIME_LATER_PLAYER.isoformat(),
            "temp_password_hash": original_temp_hash, # Should NOT change
        }
        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = data_after_update_attempt_dict
        mock_snapshot_after_update.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_update)

        with patch("app.crud.crud_player.datetime") as mock_dt_player:
            mock_dt_player.now.return_value = FIXED_DATETIME_LATER_PLAYER

            updated_player_dict = await crud_player_instance.update(
                db=mock_firestore_db, doc_id=PLAYER_UID, obj_in=update_with_password
            )

        assert updated_player_dict is not None
        updated_player = PlayerInDB(**updated_player_dict)

        # 1. Check Firestore .update() call payload
        player_doc_ref.update.assert_called_once()
        actual_update_payload = player_doc_ref.update.call_args[0][0]
        assert "password" not in actual_update_payload # CRITICAL
        assert "temp_password_hash" not in actual_update_payload # Should not be trying to update this from password
        assert actual_update_payload["username"] == update_with_password.username
        assert actual_update_payload["updated_at"] == FIXED_DATETIME_LATER_PLAYER

        # 2. Check returned PlayerInDB object
        assert updated_player.username == update_with_password.username
        assert updated_player.temp_password_hash == original_temp_hash # CRITICAL: Unchanged
>       assert updated_player.updated_at == FIXED_DATETIME_LATER_PLAYER

tests/crud/test_crud_player.py:345:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PlayerInDB(email='player.test@example.com', user_type='player', is_active=True, username='PlayerIgnoresPass', game_id=...i=False, ai_strategy=None, uid='test-player-uid-1', temp_password_hash='initial_hashed_temp_pass', current_capital=0.0)
item = 'updated_at'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'PlayerInDB' object has no attribute 'updated_at'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
______________________ test_get_players_by_game_id_found _______________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afea1b240>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891354897776'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891352197440'>

    @pytest.mark.asyncio
    async def test_get_players_by_game_id_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query # .where().limit() if limit is part of query

        async def stream_results_gen(*args, **kwargs): yield mock_player_doc_snapshot
        mock_query.stream = MagicMock(return_value=stream_results_gen())

        players_list = await crud_player_instance.get_players_by_game_id(
            db=mock_firestore_db, game_id=TEST_GAME_ID_FOR_PLAYER, limit=10 # Explicit limit
        )

>       mock_collection_ref.where.assert_called_once_with("game_id", "==", TEST_GAME_ID_FOR_PLAYER)

tests/crud/test_crud_player.py:365:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='139891356760592'>
args = ('game_id', '==', 'test-game-id-for-player-tests'), kwargs = {}
expected = call('game_id', '==', 'test-game-id-for-player-tests')
actual = call(field='game_id', op_string='==', value='test-game-id-for-player-tests')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f3afe5d4220>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('game_id', '==', 'test-game-id-for-player-tests')
E             Actual: where(field='game_id', op_string='==', value='test-game-id-for-player-tests')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
____________________ test_get_players_by_game_id_not_found _____________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe885590>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891352206512'>

    @pytest.mark.asyncio
    async def test_get_players_by_game_id_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query

        async def stream_no_results(*args, **kwargs):
            if False: yield # Empty async generator
        mock_query.stream = MagicMock(return_value=stream_no_results()) # After .limit()

        players_list = await crud_player_instance.get_players_by_game_id(
            db=mock_firestore_db, game_id="non-existent-game-id", limit=5
        )
>       mock_collection_ref.where.assert_called_once_with("game_id", "==", "non-existent-game-id")

tests/crud/test_crud_player.py:402:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='139891352200128'>
args = ('game_id', '==', 'non-existent-game-id'), kwargs = {}
expected = call('game_id', '==', 'non-existent-game-id')
actual = call(field='game_id', op_string='==', value='non-existent-game-id')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f3afe5d4fe0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('game_id', '==', 'non-existent-game-id')
E             Actual: where(field='game_id', op_string='==', value='non-existent-game-id')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
___________________ test_get_player_in_game_by_number_found ____________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3b01cb5950>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891408991104'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891356754544'>

    @pytest.mark.asyncio
    async def test_get_player_in_game_by_number_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient,
        mock_player_doc_snapshot: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        # Mocking the chain: collection.where().where().limit().stream()
        mock_query_game_id = AsyncMock(spec=AsyncQuery) # After first .where()
        mock_query_player_num = AsyncMock(spec=AsyncQuery) # After second .where()
        mock_query_limit = AsyncMock(spec=AsyncQuery)      # After .limit()

        mock_collection_ref.where.return_value = mock_query_game_id
        mock_query_game_id.where.return_value = mock_query_player_num
        mock_query_player_num.limit.return_value = mock_query_limit

        async def stream_one_result(*args, **kwargs):
            yield mock_player_doc_snapshot
        mock_query_limit.stream = MagicMock(return_value=stream_one_result())

        player_dict = await crud_player_instance.get_player_in_game_by_number(
            db=mock_firestore_db, game_id=TEST_GAME_ID_FOR_PLAYER, player_number=PLAYER_NUMBER
        )
        assert player_dict is not None
>       player = PlayerInDB(**player_dict)
E       TypeError: app.schemas.player.PlayerInDB() argument after ** must be a mapping, not PlayerInDB

tests/crud/test_crud_player.py:430: TypeError
_________________ test_get_player_in_game_by_number_not_found __________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe951450>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891352198448'>

    @pytest.mark.asyncio
    async def test_get_player_in_game_by_number_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query_game_id = AsyncMock(spec=AsyncQuery)
        mock_query_player_num = AsyncMock(spec=AsyncQuery)
        mock_query_limit = AsyncMock(spec=AsyncQuery)

        mock_collection_ref.where.return_value = mock_query_game_id
        mock_query_game_id.where.return_value = mock_query_player_num
        mock_query_player_num.limit.return_value = mock_query_limit

        async def stream_no_results(*args, **kwargs):
            if False: yield
        mock_query_limit.stream = MagicMock(return_value=stream_no_results())

        player = await crud_player_instance.get_player_in_game_by_number(
            db=mock_firestore_db, game_id="some-game-id", player_number=99
        )
        assert player is None
        calls = mock_collection_ref.where.call_args_list
>       assert calls[0][0] == ("game_id", "==", "some-game-id")
E       AssertionError: assert () == ('game_id', '...some-game-id')
E
E         Right contains 3 more items, first extra item: 'game_id'
E         Use -v to get more diff

tests/crud/test_crud_player.py:479: AssertionError
____________________ test_clear_temp_password_hash_success _____________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe9c6d50>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891354906176'>
mock_player_doc_snapshot_data = {'ai_strategy': None, 'created_at': '2023-01-02T10:00:00+00:00', 'current_capital': 0.0, 'email': 'player.test@example.com', ...}

    @pytest.mark.asyncio
    async def test_clear_temp_password_hash_success(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot_data: dict
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)

        # Data for snapshot *after* update (temp_password_hash is None)
        # This is what CRUDBase.update will make its .get() call return
        data_after_clear_dict = {
            **mock_player_doc_snapshot_data, # has ISO strings
            "temp_password_hash": None,
            "updated_at": FIXED_DATETIME_LATER_PLAYER.isoformat() # as ISO string
        }
        mock_snapshot_after_clear = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_clear.exists = True
        mock_snapshot_after_clear.to_dict.return_value = data_after_clear_dict
        mock_snapshot_after_clear.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_clear)

        # Patch datetime.now() in app.crud.crud_player (used by CRUDPlayer.update which is called by super().update)
        # and in app.crud.base (if CRUDBase.update also set it, though it doesn't)
        with patch("app.crud.crud_player.datetime") as mock_dt_player, \
>            patch("app.crud.base.datetime") as mock_dt_base: # For CRUDBase if it used it

tests/crud/test_crud_player.py:507:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:1497: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x7f3afe9343d0>

    def get_original(self):
        target = self.getter()
        name = self.attribute

        original = DEFAULT
        local = False

        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True

        if name in _builtins and isinstance(target, ModuleType):
            self.create = True

        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'app.crud.base' from '/app/backend/app/crud/base.py'> does not have the attribute 'datetime'

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:1467: AttributeError
_____________ test_clear_temp_password_hash_failure_doc_not_found ______________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe84d130>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891355273264'>

    @pytest.mark.asyncio
    async def test_clear_temp_password_hash_failure_doc_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient,
    ):
        # Patch the super().update() call within clear_temp_password_hash to simulate failure
        with patch.object(CRUDBase, "update", new_callable=AsyncMock) as mock_base_update:
            mock_base_update.return_value = None # Simulate document not found or update failure

            # We still need to patch datetime.now used by clear_temp_password_hash itself for its own updated_at
            with patch("app.crud.crud_player.datetime") as mock_dt_player:
                 mock_dt_player.now.return_value = FIXED_DATETIME_LATER_PLAYER

                 result_dict = await crud_player_instance.clear_temp_password_hash(
                    db=mock_firestore_db, player_uid="non-existent-player-uid"
                 )

        assert result_dict is None
        # Check that super().update was called correctly by clear_temp_password_hash
        expected_payload_to_base = {
            "temp_password_hash": None,
            "updated_at": FIXED_DATETIME_LATER_PLAYER
        }
>       mock_base_update.assert_called_once_with(
            db=mock_firestore_db, doc_id="non-existent-player-uid", obj_in=expected_payload_to_base
        )

tests/crud/test_crud_player.py:557:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='update' id='139891355284352'>, args = ()
kwargs = {'db': <AsyncMock spec='AsyncClient' id='139891355273264'>, 'doc_id': 'non-existent-player-uid', 'obj_in': {'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)}}
expected = call(db=<AsyncMock spec='AsyncClient' id='139891355273264'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
actual = call(<AsyncMock spec='AsyncClient' id='139891355273264'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7f3afe5d54e0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update(db=<AsyncMock spec='AsyncClient' id='139891355273264'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
E             Actual: update(<AsyncMock spec='AsyncClient' id='139891355273264'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
_________________________ test_get_player_by_id_found __________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f3afe869a90>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891355286032'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='139891353642592'>

    @pytest.mark.asyncio
    async def test_get_player_by_id_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock # Specific player snapshot
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)
        player_doc_ref.get = AsyncMock(return_value=mock_player_doc_snapshot) # Ensure this specific doc ID returns our snapshot

        player_dict = await crud_player_instance.get(db=mock_firestore_db, doc_id=PLAYER_UID)
        assert player_dict is not None
>       player = PlayerInDB(**player_dict) # Pydantic parses ISO strings
E       TypeError: app.schemas.player.PlayerInDB() argument after ** must be a mapping, not PlayerInDB

tests/crud/test_crud_player.py:573: TypeError
_______________________ test_create_player_round_result ________________________

crud_result_instance = <app.crud.crud_result.CRUDResult object at 0x7f3b01c57b10>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891354907520'>
result_create_obj_round1_player1 = ResultCreate(game_id='test-game-r1', player_id='player-r1', round_number=1, profit_or_loss=2500.0, closing_capital=0.0...ical_control=0.0, animal_feed_vet=0.0, base_operational_costs=1500.0, total=0.0), grand_total=2500.0), explanations={})
mock_result_doc_ref = <MagicMock spec='DocumentReference' id='139891352196432'>

    @pytest.mark.asyncio
    async def test_create_player_round_result(
        crud_result_instance: CRUDResult,
        mock_firestore_db: MagicMock,
        result_create_obj_round1_player1: ResultCreate, # Use specific fixture
        mock_result_doc_ref: MagicMock
    ):
        with patch.object(CRUDResult, "_get_result_doc_ref", return_value=mock_result_doc_ref) as mock_get_ref, \
             patch("app.crud.crud_result.datetime") as mock_datetime:
            mock_datetime.now.return_value = FIXED_DATETIME_RESULT
            mock_datetime.UTC = timezone.utc # Ensure datetime.UTC is available if used by SUT

            created_result = await crud_result_instance.create_player_round_result(
                db=mock_firestore_db, obj_in=result_create_obj_round1_player1
            )

        mock_get_ref.assert_called_once_with(
            mock_firestore_db,
            result_create_obj_round1_player1.game_id,
            result_create_obj_round1_player1.player_id,
            result_create_obj_round1_player1.round_number
        )
        mock_result_doc_ref.set.assert_called_once()
        call_args, _ = mock_result_doc_ref.set.call_args
        set_data = call_args[0]

        assert set_data["game_id"] == result_create_obj_round1_player1.game_id
        assert set_data["player_id"] == result_create_obj_round1_player1.player_id
        assert set_data["profit_or_loss"] == result_create_obj_round1_player1.profit_or_loss # Changed
        assert isinstance(set_data["income_details"], dict)
>       assert set_data["income_details"]["crop_sales"] == result_create_obj_round1_player1.income_details.crop_sales
E       KeyError: 'crop_sales'

tests/crud/test_crud_result.py:160: KeyError
______________________ test_get_player_round_result_found ______________________

crud_result_instance = <app.crud.crud_result.CRUDResult object at 0x7f3afe979310>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353868272'>
mock_result_doc_ref = <MagicMock spec='DocumentReference' id='139891353873984'>
result_create_obj_round1_player1 = ResultCreate(game_id='test-game-r1', player_id='player-r1', round_number=1, profit_or_loss=2500.0, closing_capital=0.0...ical_control=0.0, animal_feed_vet=0.0, base_operational_costs=1500.0, total=0.0), grand_total=2500.0), explanations={})

    @pytest.mark.asyncio
    async def test_get_player_round_result_found(
        crud_result_instance: CRUDResult,
        mock_firestore_db: MagicMock,
        mock_result_doc_ref: MagicMock,
        result_create_obj_round1_player1: ResultCreate
    ):
        mock_snapshot = create_mock_snapshot(result_create_obj_round1_player1, mock_result_doc_ref.id, FIXED_DATETIME_RESULT)
        # Pydantic model expects datetime obj for calculated_at, but Firestore to_dict might return ISO string
        # The create_mock_snapshot helper already sets calculated_at as datetime object in the dict it returns
        # so that CRUDBase can parse it directly.
        # If Firestore to_dict() returns ISO string, CRUDBase needs to handle parsing.
        # For this test, create_mock_snapshot returns datetime object for calculated_at.
        mock_result_doc_ref.get = AsyncMock(return_value=mock_snapshot)


        with patch.object(CRUDResult, "_get_result_doc_ref", return_value=mock_result_doc_ref) as mock_get_ref:
            result = await crud_result_instance.get_player_round_result(
                db=mock_firestore_db, game_id=TEST_GAME_ID, player_id=TEST_PLAYER_ID, round_number=TEST_ROUND_NUMBER
            )

        mock_get_ref.assert_called_once_with(mock_firestore_db, TEST_GAME_ID, TEST_PLAYER_ID, TEST_ROUND_NUMBER)
        assert isinstance(result, ResultInDB)

        # Comprehensive assertions for all fields
        assert result.id == mock_result_doc_ref.id
        assert result.game_id == result_create_obj_round1_player1.game_id
        assert result.player_id == result_create_obj_round1_player1.player_id
        assert result.round_number == result_create_obj_round1_player1.round_number
        assert result.calculated_at == FIXED_DATETIME_RESULT

        # Data integrity fields
>       assert result.market_demand_multiplier == result_create_obj_round1_player1.market_demand_multiplier

tests/crud/test_crud_result.py:223:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = ResultInDB(game_id='test-game-r1', player_id='player-r1', round_number=1, profit_or_loss=2500.0, closing_capital=0.0, ...={}, id='player-r1_round_1_result', calculated_at=datetime.datetime(2023, 10, 26, 12, 0, tzinfo=datetime.timezone.utc))
item = 'market_demand_multiplier'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'ResultInDB' object has no attribute 'market_demand_multiplier'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
_______________________ test_get_all_results_for_player ________________________

crud_result_instance = <app.crud.crud_result.CRUDResult object at 0x7f3afe98c3e0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353547984'>
result_create_obj_round1_player1 = ResultCreate(game_id='test-game-r1', player_id='player-r1', round_number=1, profit_or_loss=2500.0, closing_capital=0.0...ical_control=0.0, animal_feed_vet=0.0, base_operational_costs=1500.0, total=0.0), grand_total=2500.0), explanations={})
result_create_obj_round2_player1 = ResultCreate(game_id='test-game-r1', player_id='player-r1', round_number=2, profit_or_loss=1800.0, closing_capital=0.0...ical_control=0.0, animal_feed_vet=0.0, base_operational_costs=1350.0, total=0.0), grand_total=2200.0), explanations={})

    @pytest.mark.asyncio
    async def test_get_all_results_for_player(
        crud_result_instance: CRUDResult,
        mock_firestore_db: MagicMock,
        result_create_obj_round1_player1: ResultCreate,
        result_create_obj_round2_player1: ResultCreate
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=TEST_GAME_ID))
        mock_query = AsyncMock(spec=AsyncQuery) # Object returned by where().order_by().limit()
        mock_collection_ref.where.return_value = mock_query
        mock_query.order_by.return_value = mock_query # Chain order_by
        mock_query.limit.return_value = mock_query    # Chain limit

        doc_id1 = f"{TEST_PLAYER_ID}_round_{TEST_ROUND_NUMBER}_result"
        doc_id2 = f"{TEST_PLAYER_ID}_round_{TEST_ROUND_NUMBER_2}_result"

        mock_snapshot1 = create_mock_snapshot(result_create_obj_round1_player1, doc_id1, FIXED_DATETIME_RESULT)
        # For second result, use a slightly different time if it matters, or same if not.
>       mock_snapshot2 = create_mock_snapshot(result_create_obj_round2_player1, doc_id2, FIXED_DATETIME_RESULT + timezone.timedelta(minutes=1))
E       AttributeError: type object 'datetime.timezone' has no attribute 'timedelta'

tests/crud/test_crud_result.py:278: AttributeError
____________________ test_get_all_results_for_player_empty _____________________

crud_result_instance = <app.crud.crud_result.CRUDResult object at 0x7f3afe3671d0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353495808'>

    @pytest.mark.asyncio
    async def test_get_all_results_for_player_empty(
        crud_result_instance: CRUDResult,
        mock_firestore_db: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=TEST_GAME_ID))
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query
        mock_query.order_by.return_value = mock_query
        mock_query.limit.return_value = mock_query

        async def stream_no_results_gen(*args, **kwargs):
            if False: yield
        mock_query.stream = MagicMock(return_value=stream_no_results_gen())

>       results = await crud_result_instance.get_all_results_for_player(
            db=mock_firestore_db, game_id=TEST_GAME_ID, player_id="unknown_player", limit=10
        )

tests/crud/test_crud_result.py:341:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.crud.crud_result.CRUDResult object at 0x7f3afe3671d0>
db = <AsyncMock spec='AsyncClient' id='139891353495808'>

    async def get_all_results_for_player(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, game_id: str, player_id: str, limit: int = 50 # Max rounds
    ) -> List[ResultInDB]:
        """
        Get all results for a specific player in a game, ordered by round_number.
        Requires a composite index on (player_id, round_number) if 'player_results' is top-level.
        If using subcollections based on game_id, then index on round_number within that.
        """
        collection_path = RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=game_id)
        # This query strategy depends on how documents are identified and stored.
        # If doc IDs are like "playerID_round_X_result", a prefix query might be complex.
        # Easier if player_id is a field:
        query: AsyncବQuery = (
            db.collection(collection_path)
            .where(field="player_id", op_string="==", value=player_id)
            .order_by("round_number") # Ascending by default
            .limit(limit)
        )
>       snapshots = await query.stream() # type: ignore
E       TypeError: object async_generator can't be used in 'await' expression

app/crud/crud_result.py:97: TypeError
_____________________ test_get_all_results_for_game_round ______________________

crud_result_instance = <app.crud.crud_result.CRUDResult object at 0x7f3afe885590>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891349265712'>
result_create_obj_round1_player1 = ResultCreate(game_id='test-game-r1', player_id='player-r1', round_number=1, profit_or_loss=2500.0, closing_capital=0.0...ical_control=0.0, animal_feed_vet=0.0, base_operational_costs=1500.0, total=0.0), grand_total=2500.0), explanations={})
result_create_obj_round1_player2 = ResultCreate(game_id='test-game-r1', player_id='player-r2', round_number=1, profit_or_loss=2900.0, closing_capital=0.0...ical_control=0.0, animal_feed_vet=0.0, base_operational_costs=1570.0, total=0.0), grand_total=2600.0), explanations={})

    @pytest.mark.asyncio
    async def test_get_all_results_for_game_round(
        crud_result_instance: CRUDResult,
        mock_firestore_db: MagicMock,
        result_create_obj_round1_player1: ResultCreate,
        result_create_obj_round1_player2: ResultCreate # Result from another player for the same round
    ):
        mock_collection_ref = mock_firestore_db.collection(RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=TEST_GAME_ID))
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query # query.where()

        doc_id1 = f"{TEST_PLAYER_ID}_round_{TEST_ROUND_NUMBER}_result"
        doc_id2 = f"{TEST_PLAYER_ID_2}_round_{TEST_ROUND_NUMBER}_result"

        mock_snapshot1 = create_mock_snapshot(result_create_obj_round1_player1, doc_id1, FIXED_DATETIME_RESULT)
        mock_snapshot2 = create_mock_snapshot(result_create_obj_round1_player2, doc_id2, FIXED_DATETIME_RESULT)


        async def stream_results_gen(*args, **kwargs):
            yield mock_snapshot1
            yield mock_snapshot2
        mock_query.stream = MagicMock(return_value=stream_results_gen())

>       results = await crud_result_instance.get_all_results_for_game_round(
            db=mock_firestore_db, game_id=TEST_GAME_ID, round_number=TEST_ROUND_NUMBER
        )

tests/crud/test_crud_result.py:369:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.crud.crud_result.CRUDResult object at 0x7f3afe885590>
db = <AsyncMock spec='AsyncClient' id='139891349265712'>

    async def get_all_results_for_game_round(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, game_id: str, round_number: int
    ) -> List[ResultInDB]:
        """
        Get results for all players for a specific game round.
        Useful for displaying a summary/comparison at the end of a round.
        """
        collection_path = RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=game_id)
        query: AsyncବQuery = db.collection(collection_path).where(field="round_number", op_string="==", value=round_number)
>       snapshots = await query.stream() # type: ignore
E       TypeError: object async_generator can't be used in 'await' expression

app/crud/crud_result.py:116: TypeError
__________________ test_get_all_results_for_game_round_empty ___________________

crud_result_instance = <app.crud.crud_result.CRUDResult object at 0x7f3afea1a030>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891349263696'>

    @pytest.mark.asyncio
    async def test_get_all_results_for_game_round_empty(
        crud_result_instance: CRUDResult,
        mock_firestore_db: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=TEST_GAME_ID))
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query

        async def stream_no_results_gen(*args, **kwargs):
            if False: yield
        mock_query.stream = MagicMock(return_value=stream_no_results_gen())

>       results = await crud_result_instance.get_all_results_for_game_round(
            db=mock_firestore_db, game_id=TEST_GAME_ID, round_number=3 # Assuming round 3 has no results
        )

tests/crud/test_crud_result.py:409:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.crud.crud_result.CRUDResult object at 0x7f3afea1a030>
db = <AsyncMock spec='AsyncClient' id='139891349263696'>

    async def get_all_results_for_game_round(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, game_id: str, round_number: int
    ) -> List[ResultInDB]:
        """
        Get results for all players for a specific game round.
        Useful for displaying a summary/comparison at the end of a round.
        """
        collection_path = RESULT_COLLECTION_NAME_TEMPLATE.format(game_id=game_id)
        query: AsyncବQuery = db.collection(collection_path).where(field="round_number", op_string="==", value=round_number)
>       snapshots = await query.stream() # type: ignore
E       TypeError: object async_generator can't be used in 'await' expression

app/crud/crud_result.py:116: TypeError
___________________________ test_create_player_round ___________________________

crud_round_instance = <app.crud.crud_round.CRUDRound object at 0x7f3afe979950>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353872976'>
round_create_obj = RoundCreate(game_id='test-game-round-crud', player_id='player-round-crud', round_number=1, status='pending', decisions...control=False, attempt_organic_certification=False, machine_investment_level=0), is_submitted=False, submitted_at=None)
initial_parcels_data = [{'crop_sequence_effect': <CropSequenceEffect.NONE: 'keine'>, 'current_plantation': 'Brachland', 'last_harvest_outcome...on': 'Brachland', 'last_harvest_outcome_category': <HarvestOutcome.NONE: 'keiner'>, 'last_harvest_yield_dt': 0.0, ...}]
mock_round_doc_ref = <MagicMock spec='DocumentReference' id='139891352196768'>
mock_field_state_doc_ref = <MagicMock spec='DocumentReference' id='139891352199456'>

    @pytest.mark.asyncio
    async def test_create_player_round(
        crud_round_instance: CRUDRound,
        mock_firestore_db: MagicMock, # From conftest.py
        round_create_obj: RoundCreate,
        initial_parcels_data: list[dict],
        mock_round_doc_ref: MagicMock,
        mock_field_state_doc_ref: MagicMock
    ):
        # Arrange
        # Patch the helper methods that construct doc refs
        with patch.object(CRUDRound, "_get_round_doc_ref", return_value=mock_round_doc_ref) as mock_get_round_ref, \
             patch.object(CRUDRound, "_get_field_state_doc_ref", return_value=mock_field_state_doc_ref) as mock_get_field_ref, \
             patch("app.crud.crud_round.datetime") as mock_datetime: # Patch datetime used in crud_round.py

            mock_datetime.now.return_value = FIXED_DATETIME_ROUND
            mock_datetime.UTC = timezone.utc # Make sure timezone.utc is available if SUT uses datetime.UTC

            # Act
            created_round = await crud_round_instance.create_player_round(
                db=mock_firestore_db, obj_in=round_create_obj, initial_parcels=initial_parcels_data
            )

        # Assert
        mock_get_round_ref.assert_called_once_with(
            mock_firestore_db, TEST_GAME_ID_R, TEST_PLAYER_ID_R, TEST_ROUND_NUMBER_R
        )
        mock_get_field_ref.assert_called_once_with(
            mock_firestore_db, TEST_GAME_ID_R, TEST_PLAYER_ID_R, TEST_ROUND_NUMBER_R
        )

        # Check round document creation
        mock_round_doc_ref.set.assert_called_once()
        round_set_args, _ = mock_round_doc_ref.set.call_args
        round_set_data = round_set_args[0]

        assert round_set_data["game_id"] == round_create_obj.game_id
        assert round_set_data["player_id"] == round_create_obj.player_id
        assert round_set_data["round_number"] == round_create_obj.round_number
        assert round_set_data["is_submitted"] == round_create_obj.is_submitted
>       assert round_set_data["status"] == round_create_obj.status.value
E       AttributeError: 'str' object has no attribute 'value'

tests/crud/test_crud_round.py:107: AttributeError
_________________________ test_get_player_round_found __________________________

crud_round_instance = <app.crud.crud_round.CRUDRound object at 0x7f3afe98e060>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353634864'>
mock_round_doc_ref = <MagicMock spec='DocumentReference' id='139891353646288'>
round_create_obj = RoundCreate(game_id='test-game-round-crud', player_id='player-round-crud', round_number=1, status='pending', decisions...control=False, attempt_organic_certification=False, machine_investment_level=0), is_submitted=False, submitted_at=None)

    @pytest.mark.asyncio
    async def test_get_player_round_found(
        crud_round_instance: CRUDRound,
        mock_firestore_db: MagicMock, # From conftest.py
        mock_round_doc_ref: MagicMock, # From this test file's fixtures
        round_create_obj: RoundCreate # To shape the snapshot data
    ):
        # Arrange
        # Simulate the data that would be in Firestore
        snapshot_data = round_create_obj.model_dump() # Uses RoundCreate which has default decisions
        snapshot_data["id"] = mock_round_doc_ref.id
        snapshot_data["created_at"] = FIXED_DATETIME_ROUND # Match Pydantic model type
        snapshot_data["updated_at"] = FIXED_DATETIME_ROUND
        # Ensure decisions are dict if Pydantic model was used to create snapshot_data
        if isinstance(snapshot_data["decisions"], BaseModel):
            snapshot_data["decisions"] = snapshot_data["decisions"].model_dump()


        mock_snapshot = MagicMock(spec=DocumentSnapshot)
        mock_snapshot.exists = True
        # snapshot.to_dict() should return data that can be parsed by RoundInDB
        # which means datetime fields should be datetime objects or ISO strings
        # Forcing ISO string here to mimic Firestore, Pydantic will parse it.
        dict_return = snapshot_data.copy()
        dict_return["created_at"] = FIXED_DATETIME_ROUND.isoformat()
        dict_return["updated_at"] = FIXED_DATETIME_ROUND.isoformat()
        mock_snapshot.to_dict.return_value = dict_return
        mock_snapshot.id = mock_round_doc_ref.id # Ensure snapshot has the ID

        mock_round_doc_ref.get = AsyncMock(return_value=mock_snapshot)

        with patch.object(CRUDRound, "_get_round_doc_ref", return_value=mock_round_doc_ref) as mock_get_ref:
            # Act
            result = await crud_round_instance.get_player_round(
                db=mock_firestore_db,
                game_id=TEST_GAME_ID_R,
                player_id=TEST_PLAYER_ID_R,
                round_number=TEST_ROUND_NUMBER_R
            )

        # Assert
        mock_get_ref.assert_called_once_with(mock_firestore_db, TEST_GAME_ID_R, TEST_PLAYER_ID_R, TEST_ROUND_NUMBER_R)
        assert isinstance(result, RoundInDB)
        assert result.id == mock_round_doc_ref.id
        assert result.game_id == round_create_obj.game_id
        assert result.player_id == round_create_obj.player_id
        assert result.round_number == round_create_obj.round_number
        assert result.decisions == round_create_obj.decisions # Compares Pydantic models
        assert result.is_submitted == round_create_obj.is_submitted
        assert result.status == round_create_obj.status
        assert result.created_at == FIXED_DATETIME_ROUND
        assert result.updated_at == FIXED_DATETIME_ROUND # From snapshot_data
        assert result.submitted_at is None # Was not set in round_create_obj
>       assert result.result_id is None # Was not set

tests/crud/test_crud_round.py:388:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = RoundInDB(game_id='test-game-round-crud', player_id='player-round-crud', round_number=1, status='pending', decisions=R...datetime(2023, 11, 1, 12, 0, tzinfo=TzInfo(UTC)), updated_at=datetime.datetime(2023, 11, 1, 12, 0, tzinfo=TzInfo(UTC)))
item = 'result_id'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'RoundInDB' object has no attribute 'result_id'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
___________ test_get_all_player_rounds_for_game_round_multiple_found ___________

crud_round_instance = <app.crud.crud_round.CRUDRound object at 0x7f3afea1a470>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139891353632848'>
round_create_obj = RoundCreate(game_id='test-game-round-crud', player_id='player-round-crud', round_number=1, status='pending', decisions...control=False, attempt_organic_certification=False, machine_investment_level=0), is_submitted=False, submitted_at=None)
round_create_obj_player2_round1 = RoundCreate(game_id='test-game-round-crud', player_id='player-round-crud_player2', round_number=1, status='pending', d...control=False, attempt_organic_certification=False, machine_investment_level=0), is_submitted=False, submitted_at=None)

    @pytest.mark.asyncio
    async def test_get_all_player_rounds_for_game_round_multiple_found(
        crud_round_instance: CRUDRound,
        mock_firestore_db: MagicMock,
        round_create_obj: RoundCreate, # Player 1, Round 1
        round_create_obj_player2_round1: RoundCreate # Player 2, Round 1
    ):
        # Arrange
        collection_path = ROUND_COLLECTION_NAME_TEMPLATE.format(game_id=TEST_GAME_ID_R)
        mock_collection_ref = mock_firestore_db.collection(collection_path)

        mock_query = AsyncMock(spec=AsyncQuery) # Object returned by where()
        mock_collection_ref.where.return_value = mock_query

        mock_snapshot_p1r1 = create_round_mock_snapshot(round_create_obj)
        mock_snapshot_p2r1 = create_round_mock_snapshot(round_create_obj_player2_round1)

        async def stream_results_gen(*args, **kwargs):
            yield mock_snapshot_p1r1
            yield mock_snapshot_p2r1

        # query.stream is a sync method returning an async iterator
        mock_query.stream = MagicMock(return_value=stream_results_gen())

        # Act
        results = await crud_round_instance.get_all_player_rounds_for_game_round(
            db=mock_firestore_db, game_id=TEST_GAME_ID_R, round_number=TEST_ROUND_NUMBER_R
        )

        # Assert
        mock_collection_ref.where.assert_called_once_with(field="round_number", op_string="==", value=TEST_ROUND_NUMBER_R)

        assert len(results) == 2
        assert len(results) == 2

        # Create a map for easier lookup and assertion
        expected_rounds_data = {
            mock_snapshot_p1r1.id: round_create_obj,
            mock_snapshot_p2r1.id: round_create_obj_player2_round1
        }

        for res_obj in results:
            assert isinstance(res_obj, RoundInDB)
            assert res_obj.id in expected_rounds_data
            expected_data_create_obj = expected_rounds_data[res_obj.id]

            assert res_obj.game_id == expected_data_create_obj.game_id
            assert res_obj.player_id == expected_data_create_obj.player_id
            assert res_obj.round_number == expected_data_create_obj.round_number
            assert res_obj.decisions == expected_data_create_obj.decisions
            assert res_obj.is_submitted == expected_data_create_obj.is_submitted
            assert res_obj.status == expected_data_create_obj.status
            assert res_obj.created_at == FIXED_DATETIME_ROUND # Based on create_round_mock_snapshot
            assert res_obj.updated_at == FIXED_DATETIME_ROUND # Based on create_round_mock_snapshot
            assert res_obj.submitted_at is None # Not set in create_obj
>           assert res_obj.result_id is None # Not set in create_obj

tests/crud/test_crud_round.py:498:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = RoundInDB(game_id='test-game-round-crud', player_id='player-round-crud', round_number=1, status='pending', decisions=R...datetime(2023, 11, 1, 12, 0, tzinfo=TzInfo(UTC)), updated_at=datetime.datetime(2023, 11, 1, 12, 0, tzinfo=TzInfo(UTC)))
item = 'result_id'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'RoundInDB' object has no attribute 'result_id'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
=========================== short test summary info ============================
FAILED tests/crud/test_crud_admin.py::test_create_admin_with_uid - AssertionE...
FAILED tests/crud/test_crud_admin.py::test_get_admin_by_email_found - Attribu...
FAILED tests/crud/test_crud_admin.py::test_update_admin - KeyError: 'full_name'
FAILED tests/crud/test_crud_admin.py::test_update_admin_ignores_password - Ke...
FAILED tests/crud/test_crud_admin.py::test_update_admin_non_existent - Assert...
FAILED tests/crud/test_crud_admin.py::test_get_admin_by_id_found - TypeError:...
FAILED tests/crud/test_crud_admin.py::test_get_multi_admins - AttributeError:...
FAILED tests/crud/test_crud_game.py::test_create_game_with_admin - AttributeE...
FAILED tests/crud/test_crud_game.py::test_get_games_by_admin_id_found - Asser...
FAILED tests/crud/test_crud_game.py::test_add_player_to_game_success - Assert...
FAILED tests/crud/test_crud_game.py::test_remove_player_from_game_success - A...
FAILED tests/crud/test_crud_game.py::test_update_game_status - AssertionError...
FAILED tests/crud/test_crud_game.py::test_get_game_by_id_found - TypeError: a...
FAILED tests/crud/test_crud_player.py::test_create_player_with_uid - KeyError...
FAILED tests/crud/test_crud_player.py::test_get_player_by_email_found - TypeE...
FAILED tests/crud/test_crud_player.py::test_update_player - AttributeError: <...
FAILED tests/crud/test_crud_player.py::test_update_player_ignores_password - ...
FAILED tests/crud/test_crud_player.py::test_get_players_by_game_id_found - As...
FAILED tests/crud/test_crud_player.py::test_get_players_by_game_id_not_found
FAILED tests/crud/test_crud_player.py::test_get_player_in_game_by_number_found
FAILED tests/crud/test_crud_player.py::test_get_player_in_game_by_number_not_found
FAILED tests/crud/test_crud_player.py::test_clear_temp_password_hash_success
FAILED tests/crud/test_crud_player.py::test_clear_temp_password_hash_failure_doc_not_found
FAILED tests/crud/test_crud_player.py::test_get_player_by_id_found - TypeErro...
FAILED tests/crud/test_crud_result.py::test_create_player_round_result - KeyE...
FAILED tests/crud/test_crud_result.py::test_get_player_round_result_found - A...
FAILED tests/crud/test_crud_result.py::test_get_all_results_for_player - Attr...
FAILED tests/crud/test_crud_result.py::test_get_all_results_for_player_empty
FAILED tests/crud/test_crud_result.py::test_get_all_results_for_game_round - ...
FAILED tests/crud/test_crud_result.py::test_get_all_results_for_game_round_empty
FAILED tests/crud/test_crud_round.py::test_create_player_round - AttributeErr...
FAILED tests/crud/test_crud_round.py::test_get_player_round_found - Attribute...
FAILED tests/crud/test_crud_round.py::test_get_all_player_rounds_for_game_round_multiple_found
======================== 33 failed, 56 passed in 2.42s =========================
 /app/backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:208: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
