/app/backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:208: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
============================= test session starts ==============================
platform linux -- Python 3.13.3, pytest-8.3.5, pluggy-1.6.0 -- /app/backend/.venv/bin/python
cachedir: .pytest_cache
rootdir: /app/backend
configfile: pyproject.toml
plugins: asyncio-1.0.0, cov-6.1.1, anyio-4.9.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 60 items

tests/crud/test_crud_admin.py::test_create_admin_with_uid PASSED         [  1%]
tests/crud/test_crud_admin.py::test_get_admin_by_email_found PASSED      [  3%]
tests/crud/test_crud_admin.py::test_get_admin_by_email_not_found PASSED  [  5%]
tests/crud/test_crud_admin.py::test_update_admin FAILED                  [  6%]
tests/crud/test_crud_admin.py::test_update_admin_ignores_password FAILED [  8%]
tests/crud/test_crud_admin.py::test_update_admin_non_existent PASSED     [ 10%]
tests/crud/test_crud_admin.py::test_get_admin_by_id_found PASSED         [ 11%]
tests/crud/test_crud_admin.py::test_get_admin_by_id_not_found PASSED     [ 13%]
tests/crud/test_crud_admin.py::test_get_multi_admins PASSED              [ 15%]
tests/crud/test_crud_admin.py::test_get_multi_admins_empty PASSED        [ 16%]
tests/crud/test_crud_admin.py::test_remove_admin_success PASSED          [ 18%]
tests/crud/test_crud_admin.py::test_remove_admin_non_existent PASSED     [ 20%]
tests/crud/test_crud_game.py::test_create_game_with_admin PASSED         [ 21%]
tests/crud/test_crud_game.py::test_get_games_by_admin_id_found FAILED    [ 23%]
tests/crud/test_crud_game.py::test_get_games_by_admin_id_not_found PASSED [ 25%]
tests/crud/test_crud_game.py::test_add_player_to_game_success FAILED     [ 26%]
tests/crud/test_crud_game.py::test_add_player_to_game_firestore_error PASSED [ 28%]
tests/crud/test_crud_game.py::test_remove_player_from_game_success FAILED [ 30%]
tests/crud/test_crud_game.py::test_remove_player_from_game_firestore_error PASSED [ 31%]
tests/crud/test_crud_game.py::test_update_game_status PASSED             [ 33%]
tests/crud/test_crud_game.py::test_update_game_status_parametrized[active] PASSED [ 35%]
tests/crud/test_crud_game.py::test_update_game_status_parametrized[pending] PASSED [ 36%]
tests/crud/test_crud_game.py::test_update_game_status_parametrized[finished] PASSED [ 38%]
tests/crud/test_crud_game.py::test_update_game_status_parametrized[archived] PASSED [ 40%]
tests/crud/test_crud_game.py::test_get_game_by_id_found FAILED           [ 41%]
tests/crud/test_crud_game.py::test_get_game_by_id_not_found PASSED       [ 43%]
tests/crud/test_crud_game.py::test_update_game_general PASSED            [ 45%]
tests/crud/test_crud_game.py::test_remove_game_success PASSED            [ 46%]
tests/crud/test_crud_player.py::test_create_player_with_uid PASSED       [ 48%]
tests/crud/test_crud_player.py::test_get_player_by_email_found FAILED    [ 50%]
tests/crud/test_crud_player.py::test_get_player_by_email_not_found PASSED [ 51%]
tests/crud/test_crud_player.py::test_update_player PASSED                [ 53%]
tests/crud/test_crud_player.py::test_update_player_ignores_password PASSED [ 55%]
tests/crud/test_crud_player.py::test_get_players_by_game_id_found FAILED [ 56%]
tests/crud/test_crud_player.py::test_get_players_by_game_id_not_found PASSED [ 58%]
tests/crud/test_crud_player.py::test_get_player_in_game_by_number_found PASSED [ 60%]
tests/crud/test_crud_player.py::test_get_player_in_game_by_number_not_found PASSED [ 61%]
tests/crud/test_crud_player.py::test_clear_temp_password_hash_success PASSED [ 63%]
tests/crud/test_crud_player.py::test_clear_temp_password_hash_failure_doc_not_found FAILED [ 65%]
tests/crud/test_crud_player.py::test_get_player_by_id_found PASSED       [ 66%]
tests/crud/test_crud_player.py::test_get_player_by_id_not_found PASSED   [ 68%]
tests/crud/test_crud_player.py::test_remove_player_success PASSED        [ 70%]
tests/crud/test_crud_result.py::test_create_player_round_result PASSED   [ 71%]
tests/crud/test_crud_result.py::test_get_player_round_result_found PASSED [ 73%]
tests/crud/test_crud_result.py::test_get_player_round_result_not_found PASSED [ 75%]
tests/crud/test_crud_result.py::test_get_all_results_for_player PASSED   [ 76%]
tests/crud/test_crud_result.py::test_get_all_results_for_player_empty PASSED [ 78%]
tests/crud/test_crud_result.py::test_get_all_results_for_game_round PASSED [ 80%]
tests/crud/test_crud_result.py::test_get_all_results_for_game_round_empty PASSED [ 81%]
tests/crud/test_crud_round.py::test_create_player_round FAILED           [ 83%]
tests/crud/test_crud_round.py::test_update_player_round_decisions PASSED [ 85%]
tests/crud/test_crud_round.py::test_update_player_round_decisions_not_submitted PASSED [ 86%]
tests/crud/test_crud_round.py::test_get_player_round_found PASSED        [ 88%]
tests/crud/test_crud_round.py::test_get_player_round_not_found PASSED    [ 90%]
tests/crud/test_crud_round.py::test_get_all_player_rounds_for_game_round_multiple_found PASSED [ 91%]
tests/crud/test_crud_round.py::test_get_all_player_rounds_for_game_round_empty PASSED [ 93%]
tests/crud/test_crud_round.py::test_set_round_calculated_success PASSED  [ 95%]
tests/crud/test_crud_round.py::test_set_round_calculated_failure_exception PASSED [ 96%]
tests/crud/test_crud_round.py::test_get_player_field_state_found PASSED  [ 98%]
tests/crud/test_crud_round.py::test_get_player_field_state_not_found PASSED [100%]

=================================== FAILURES ===================================
______________________________ test_update_admin _______________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe138cfb230>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605295005712'>
admin_update_obj = AdminUpdate(email='updated.admin@example.com', first_name='UpdatedTest', last_name='AdminUser', institution='Updated University', is_active=None, password=None)
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140605295010416'>

    @pytest.mark.asyncio
    async def test_update_admin(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_update_obj: AdminUpdate,
        mock_doc_snapshot: MagicMock # Represents state *before* update for the first .get()
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        # Data for snapshot returned *after* update.
        # This should reflect the changes made by admin_update_obj.
        # Original created_at, user_type, and hashed_password should remain.
        original_doc_data_before_update = mock_doc_snapshot.to_dict() # Data from ADMIN_IN_DB_DICT_BASE + timestamps
        expected_full_name_after_update = f"{admin_update_obj.first_name} {admin_update_obj.last_name}"

        data_after_update_dict = {
            **original_doc_data_before_update, # Start with existing data
            "first_name": admin_update_obj.first_name,
            "last_name": admin_update_obj.last_name,
            "full_name": expected_full_name_after_update,
            "email": admin_update_obj.email,
            "institution": admin_update_obj.institution,
            "updated_at": FIXED_DATETIME_LATER, # This will be set by the update method in CRUDAdmin
            # Fields that should NOT change:
            "created_at": original_doc_data_before_update["created_at"],
            "hashed_password": original_doc_data_before_update["hashed_password"],
            "user_type": original_doc_data_before_update["user_type"], # Keep as string from original data
            "is_superuser": original_doc_data_before_update["is_superuser"],
            # is_active can be changed by AdminUpdate, so if it's in admin_update_obj, it should be here
            "is_active": admin_update_obj.is_active if admin_update_obj.is_active is not None else original_doc_data_before_update["is_active"],
        }

        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = data_after_update_dict
        mock_snapshot_after_update.id = ADMIN_UID

        # CRUDBase.update calls doc_ref.update() then doc_ref.get().
        # The mock_doc_snapshot fixture (passed to this test) represents the state *before* this update.
        # It's used by CRUDBase if it internally calls .get() before .update() (which it doesn't explicitly).
        # More importantly, the .get() *after* the .update() call needs to return the new state.
        mock_doc_ref_for_admin_uid.get = AsyncMock(return_value=mock_snapshot_after_update)


        # Patch datetime.now() in app.crud.crud_admin.py as it's used by CRUDAdmin.update
        with patch("app.crud.crud_admin.datetime") as mock_datetime_crud_admin_module:
            # Mock datetime.now(timezone.utc) specifically if that's what's used.
            # If it's just datetime.now(), this is fine.
            mock_datetime_crud_admin_module.now.return_value = FIXED_DATETIME_LATER # Time of update

            # Act
            updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=ADMIN_UID, obj_in=admin_update_obj
            )

        # Assert
        assert updated_admin_dict is not None, "Update should return the updated admin dictionary."
        updated_admin = AdminInDB(**updated_admin_dict)

        # 1. Check what was passed to Firestore's .update() method
        mock_doc_ref_for_admin_uid.update.assert_called_once()
        args_to_update, _ = mock_doc_ref_for_admin_uid.update.call_args
        actual_update_payload = args_to_update[0]

        assert "password" not in actual_update_payload, "Plain password should not be in Firestore update payload."
        assert "hashed_password" not in actual_update_payload, "Hashed password should not be sent directly in this payload."
        assert actual_update_payload["first_name"] == admin_update_obj.first_name
        assert actual_update_payload["last_name"] == admin_update_obj.last_name
        assert actual_update_payload["email"] == admin_update_obj.email
        assert actual_update_payload["institution"] == admin_update_obj.institution
        assert actual_update_payload["full_name"] == expected_full_name_after_update
        assert actual_update_payload["updated_at"] == FIXED_DATETIME_LATER # This must be set by CRUDAdmin.update
        if admin_update_obj.is_active is not None:
            assert actual_update_payload["is_active"] == admin_update_obj.is_active

        # 2. Check the returned AdminInDB object (comes from the .get() call after update)
        assert updated_admin.first_name == admin_update_obj.first_name
        assert updated_admin.full_name == expected_full_name_after_update
        assert updated_admin.email == admin_update_obj.email
        assert updated_admin.institution == admin_update_obj.institution
        if admin_update_obj.is_active is not None:
            assert updated_admin.is_active == admin_update_obj.is_active
        else:
            assert updated_admin.is_active == original_doc_data_before_update["is_active"]

        assert updated_admin.updated_at == FIXED_DATETIME_LATER
        assert updated_admin.created_at == original_doc_data_before_update["created_at"], "created_at should not change."
>       assert updated_admin.user_type.value == original_doc_data_before_update["user_type"], "user_type should not change by default."
E       AttributeError: 'str' object has no attribute 'value'

tests/crud/test_crud_admin.py:334: AttributeError
______________________ test_update_admin_ignores_password ______________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe138af03b0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605295014784'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140605293890256'>

    @pytest.mark.asyncio
    async def test_update_admin_ignores_password(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # Represents current state in DB (before this specific test's update)
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        original_doc_data = mock_doc_snapshot.to_dict()
        original_hashed_password = original_doc_data["hashed_password"]
        original_created_at = original_doc_data["created_at"]
        original_user_type_str = original_doc_data["user_type"] # e.g., "admin"
        original_is_superuser = original_doc_data["is_superuser"]
        original_is_active = original_doc_data["is_active"]


        update_payload_with_password = AdminUpdate(
            first_name="PasswordTestFirstName", # Changed field
            # last_name, email, institution will be None, so they shouldn't be in payload unless model_dump(exclude_none=False)
            # CRUDAdmin.update uses obj_in.model_dump(exclude_unset=True, exclude_none=True)
            # So only first_name and password (which is then deleted) will be in update_data from AdminUpdate.
            password="newfakepassword123" # This should be ignored by CRUDAdmin.update logic
        )

        # Data for snapshot returned *after* this specific update attempt.
        # Only first_name and updated_at should change. Password-related fields remain untouched.
        data_after_update_attempt_dict = {
            **original_doc_data, # Start with existing data
            "first_name": update_payload_with_password.first_name,
            # full_name should also update if first_name changes and last_name is present
            "full_name": f"{update_payload_with_password.first_name} {original_doc_data['last_name']}",
            "updated_at": FIXED_DATETIME_LATER, # This will be set by CRUDAdmin.update
            # Fields that should NOT change:
            "hashed_password": original_hashed_password,
            "created_at": original_created_at,
            "user_type": original_user_type_str, # Keep as string from original data
            "email": original_doc_data["email"], # Unchanged as not in update_payload_with_password
            "last_name": original_doc_data["last_name"], # Unchanged
            "institution": original_doc_data["institution"], # Unchanged
            "is_superuser": original_is_superuser, # Unchanged
            "is_active": original_is_active, # Unchanged
        }
        mock_snapshot_after_update_attempt = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update_attempt.exists = True
        mock_snapshot_after_update_attempt.to_dict.return_value = data_after_update_attempt_dict
        mock_snapshot_after_update_attempt.id = ADMIN_UID

        # Configure .get() on the specific doc ref to return the state *after* the update call
        mock_doc_ref_for_admin_uid.get = AsyncMock(return_value=mock_snapshot_after_update_attempt)

        with patch("app.crud.crud_admin.datetime") as mock_datetime_module:
            mock_datetime_module.now.return_value = FIXED_DATETIME_LATER # Time of update

            # Act
            updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=ADMIN_UID, obj_in=update_payload_with_password
            )

        # Assert
        assert updated_admin_dict is not None, "Update should return a dictionary even if only timestamps change."
        updated_admin = AdminInDB(**updated_admin_dict)

        # 1. Check what was passed to Firestore's .update() method
        mock_doc_ref_for_admin_uid.update.assert_called_once()
        args_to_update, _ = mock_doc_ref_for_admin_uid.update.call_args
        actual_update_payload = args_to_update[0]

        assert "password" not in actual_update_payload, "Plain password should NOT be in Firestore update payload."
        assert "hashed_password" not in actual_update_payload, "Hashed password should NOT be in this update payload."
        assert actual_update_payload["first_name"] == update_payload_with_password.first_name
        assert "last_name" not in actual_update_payload # Was not in AdminUpdate with exclude_none=True
        assert "email" not in actual_update_payload # Was not in AdminUpdate
        assert actual_update_payload["full_name"] == f"{update_payload_with_password.first_name} {original_doc_data['last_name']}"
        assert actual_update_payload["updated_at"] == FIXED_DATETIME_LATER

        # 2. Check the returned AdminInDB object
        assert updated_admin.first_name == update_payload_with_password.first_name
        assert updated_admin.full_name == f"{update_payload_with_password.first_name} {original_doc_data['last_name']}"
        assert updated_admin.email == original_doc_data["email"] # Unchanged
        assert updated_admin.hashed_password == original_hashed_password, "Hashed password must remain unchanged."
        assert updated_admin.updated_at == FIXED_DATETIME_LATER
        assert updated_admin.created_at == original_created_at, "created_at must remain unchanged."
>       assert updated_admin.user_type.value == original_user_type_str, "user_type must remain unchanged."
E       AttributeError: 'str' object has no attribute 'value'

tests/crud/test_crud_admin.py:422: AttributeError
_______________________ test_get_games_by_admin_id_found _______________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7fe138d03250>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605294140720'>
mock_game_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140605292562480'>

    @pytest.mark.asyncio
    async def test_get_games_by_admin_id_found(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_game_doc_snapshot: MagicMock # Specific snapshot for a game
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES)
        mock_query = AsyncMock(spec=AsyncQuery) # This is the object after .where().limit() etc.
        mock_collection_ref.where.return_value = mock_query # Assuming where returns the final query obj for simplicity here

        async def stream_results_gen(*args, **kwargs):
            yield mock_game_doc_snapshot

        # query.stream is a method that returns an async generator
        mock_query.stream = MagicMock(return_value=stream_results_gen())

        games_list = await crud_game_instance.get_games_by_admin_id(db=mock_firestore_db, admin_id=ADMIN_ID)

>       mock_collection_ref.where.assert_called_once_with("admin_id", "==", ADMIN_ID)

tests/crud/test_crud_game.py:199:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='140605292560464'>
args = ('admin_id', '==', 'admin-user-id-abc'), kwargs = {}
expected = call('admin_id', '==', 'admin-user-id-abc')
actual = call(field='admin_id', op_string='==', value='admin-user-id-abc')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe13891f560>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('admin_id', '==', 'admin-user-id-abc')
E             Actual: where(field='admin_id', op_string='==', value='admin-user-id-abc')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
_______________________ test_add_player_to_game_success ________________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7fe138cfbbb0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605295010752'>
mock_array_union_class = <MagicMock name='ArrayUnion' id='140605295864064'>

    @pytest.mark.asyncio
    async def test_add_player_to_game_success(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_array_union_class # From conftest.py (patches google.cloud.firestore.ArrayUnion)
    ):
        game_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES).document(TEST_GAME_ID)
        # game_doc_ref.update is an AsyncMock from mock_firestore_db in conftest

        result = await crud_game_instance.add_player_to_game(
            db=mock_firestore_db, game_id=TEST_GAME_ID, player_uid=PLAYER_UID_1
        )
        assert result is True
        # mock_array_union_class is the MagicMock for the class ArrayUnion
        # Its return_value is what's passed to update
        mock_array_union_class.assert_called_once_with([PLAYER_UID_1])
>       game_doc_ref.update.assert_called_once_with({"player_uids": mock_array_union_class.return_value})

tests/crud/test_crud_game.py:257:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.update' id='140605295002016'>
args = ({'player_uids': <MagicMock name='ArrayUnion()' id='140605295859696'>},)
kwargs = {}
expected = call({'player_uids': <MagicMock name='ArrayUnion()' id='140605295859696'>})
actual = call({'player_uids': ['player-uid-xyz']})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe138aac680>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update({'player_uids': <MagicMock name='ArrayUnion()' id='140605295859696'>})
E             Actual: update({'player_uids': ['player-uid-xyz']})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
_____________________ test_remove_player_from_game_success _____________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7fe138b87130>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605294329936'>
mock_array_remove_class = <MagicMock name='ArrayRemove' id='140605294341360'>

    @pytest.mark.asyncio
    async def test_remove_player_from_game_success(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_array_remove_class # From conftest.py
    ):
        game_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_GAMES).document(TEST_GAME_ID)

        result = await crud_game_instance.remove_player_from_game(
            db=mock_firestore_db, game_id=TEST_GAME_ID, player_uid=PLAYER_UID_1
        )
        assert result is True
        mock_array_remove_class.assert_called_once_with([PLAYER_UID_1])
>       game_doc_ref.update.assert_called_once_with({"player_uids": mock_array_remove_class.return_value})

tests/crud/test_crud_game.py:291:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.update' id='140605294334976'>
args = ({'player_uids': <MagicMock name='ArrayRemove()' id='140605294341696'>},)
kwargs = {}
expected = call({'player_uids': <MagicMock name='ArrayRemove()' id='140605294341696'>})
actual = call({'player_uids': ['player-uid-xyz']})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe13886d580>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update({'player_uids': <MagicMock name='ArrayRemove()' id='140605294341696'>})
E             Actual: update({'player_uids': ['player-uid-xyz']})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
__________________________ test_get_game_by_id_found ___________________________

crud_game_instance = <app.crud.crud_game.CRUDGame object at 0x7fe138c05ef0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605294134672'>
mock_game_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140605293925040'>

    @pytest.mark.asyncio
    async def test_get_game_by_id_found(
        crud_game_instance: CRUDGame,
        mock_firestore_db: AsyncFirestoreClient,
        mock_game_doc_snapshot: MagicMock
    ):
        # mock_game_doc_snapshot is configured by its fixture
        game_model_instance = await crud_game_instance.get(db=mock_firestore_db, doc_id=TEST_GAME_ID)
        assert game_model_instance is not None
        game = game_model_instance # get() returns a model instance

        # Comprehensive check of all fields based on mock_game_doc_snapshot_data / BASE_GAME_IN_DB_DICT
        assert game.id == TEST_GAME_ID
>       assert game.uid == TEST_GAME_ID

tests/crud/test_crud_game.py:452:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = GameInDB(name='Test Game Alpha', number_of_rounds=5, max_players=2, id='test-game-id-123', admin_id='admin-user-id-abc...e=['Normal', 'Drought', 'Normal'], vermin_sequence=['None', 'Aphids', 'None'], player_uids=[], ai_player_strategies={})
item = 'uid'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'GameInDB' object has no attribute 'uid'. Did you mean: 'id'?

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
________________________ test_get_player_by_email_found ________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe138868410>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605289195440'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140605289193424'>

    @pytest.mark.asyncio
    async def test_get_player_by_email_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock # Specific player snapshot
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query

        async def stream_results_gen(*args, **kwargs): yield mock_player_doc_snapshot
        # query.limit(1).stream() -> query.limit() returns a new query object.
        # So, the final object that .stream() is called on needs to have .stream mocked.
        mock_limit_query = AsyncMock(spec=AsyncQuery)
        mock_query.limit = MagicMock(return_value=mock_limit_query)
        mock_limit_query.stream = MagicMock(return_value=stream_results_gen())


        player_dict_or_model = await crud_player_instance.get_by_email(db=mock_firestore_db, email=PLAYER_EMAIL)
        assert player_dict_or_model is not None
        player = player_dict_or_model # Changed: crud.get_by_email returns a model instance

        # Comprehensive assertions
        assert player.uid == PLAYER_UID
        # assert player.id == PLAYER_UID # id is not a field on PlayerInDB, uid is the id.
        assert player.email == PLAYER_EMAIL
        assert player.game_id == TEST_GAME_ID_FOR_PLAYER
        assert player.player_number == PLAYER_NUMBER
        assert player.username == BASE_PLAYER_IN_DB_DICT["username"]
        assert player.user_type == UserType.PLAYER
        assert player.is_active == BASE_PLAYER_IN_DB_DICT["is_active"]
        assert player.is_superuser == BASE_PLAYER_IN_DB_DICT["is_superuser"]
        assert player.created_at == FIXED_DATETIME_NOW_PLAYER
        assert player.updated_at == FIXED_DATETIME_NOW_PLAYER
        assert player.current_capital == BASE_PLAYER_IN_DB_DICT["current_capital"]
        assert player.is_ai == BASE_PLAYER_IN_DB_DICT["is_ai"]
        assert player.ai_strategy == BASE_PLAYER_IN_DB_DICT["ai_strategy"]
        assert player.temp_password_hash == BASE_PLAYER_IN_DB_DICT["temp_password_hash"]

>       mock_collection_ref.where.assert_called_once_with("email", "==", PLAYER_EMAIL)

tests/crud/test_crud_player.py:218:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='140605289194768'>
args = ('email', '==', 'player.test@example.com'), kwargs = {}
expected = call('email', '==', 'player.test@example.com')
actual = call(field='email', op_string='==', value='player.test@example.com')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe138a25120>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('email', '==', 'player.test@example.com')
E             Actual: where(field='email', op_string='==', value='player.test@example.com')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
______________________ test_get_players_by_game_id_found _______________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe138b859d0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605292572224'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140605289500016'>

    @pytest.mark.asyncio
    async def test_get_players_by_game_id_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query # .where().limit() if limit is part of query

        async def stream_results_gen_async(*args, **kwargs):
            yield mock_player_doc_snapshot
        mock_query.stream = stream_results_gen_async

        players_list = await crud_player_instance.get_players_by_game_id(
            db=mock_firestore_db, game_id=TEST_GAME_ID_FOR_PLAYER, limit=10 # Explicit limit
        )

        mock_collection_ref.where.assert_called_once_with(field="game_id", op_string="==", value=TEST_GAME_ID_FOR_PLAYER)
        mock_query.limit.assert_called_once_with(10) # Check limit passed to query

>       assert len(players_list) == 1
E       assert 0 == 1
E        +  where 0 = len([])

tests/crud/test_crud_player.py:366: AssertionError
_____________ test_clear_temp_password_hash_failure_doc_not_found ______________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe1389e07d0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605288710560'>

    @pytest.mark.asyncio
    async def test_clear_temp_password_hash_failure_doc_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient,
    ):
        # Patch the super().update() call within clear_temp_password_hash to simulate failure
        with patch.object(CRUDBase, "update", new_callable=AsyncMock) as mock_base_update:
            mock_base_update.return_value = None # Simulate document not found or update failure

            # We still need to patch datetime.now used by clear_temp_password_hash itself for its own updated_at
            with patch("app.crud.crud_player.datetime") as mock_dt_player:
                 mock_dt_player.now.return_value = FIXED_DATETIME_LATER_PLAYER

                 result_dict = await crud_player_instance.clear_temp_password_hash(
                    db=mock_firestore_db, player_uid="non-existent-player-uid"
                 )

        assert result_dict is None
        # Check that super().update was called correctly by clear_temp_password_hash
        expected_payload_to_base = {
            "temp_password_hash": None,
            "updated_at": FIXED_DATETIME_LATER_PLAYER
        }
>       mock_base_update.assert_called_once_with(
            db=mock_firestore_db, doc_id="non-existent-player-uid", obj_in=expected_payload_to_base
        )

tests/crud/test_crud_player.py:557:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='update' id='140605289508416'>, args = ()
kwargs = {'db': <AsyncMock spec='AsyncClient' id='140605288710560'>, 'doc_id': 'non-existent-player-uid', 'obj_in': {'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)}}
expected = call(db=<AsyncMock spec='AsyncClient' id='140605288710560'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
actual = call(<AsyncMock spec='AsyncClient' id='140605288710560'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe1385c7880>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update(db=<AsyncMock spec='AsyncClient' id='140605288710560'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
E             Actual: update(<AsyncMock spec='AsyncClient' id='140605288710560'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
___________________________ test_create_player_round ___________________________

crud_round_instance = <app.crud.crud_round.CRUDRound object at 0x7fe138868690>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140605288716944'>
round_create_obj = RoundCreate(game_id='test-game-round-crud', player_id='player-round-crud', round_number=1, status='pending', decisions...control=False, attempt_organic_certification=False, machine_investment_level=0), is_submitted=False, submitted_at=None)
initial_parcels_data = [{'crop_sequence_effect': <CropSequenceEffect.NONE: 'keine'>, 'current_plantation': 'Brachland', 'last_harvest_outcome...on': 'Brachland', 'last_harvest_outcome_category': <HarvestOutcome.NONE: 'keiner'>, 'last_harvest_yield_dt': 0.0, ...}]
mock_round_doc_ref = <MagicMock spec='DocumentReference' id='140605288721312'>
mock_field_state_doc_ref = <MagicMock spec='DocumentReference' id='140605288724336'>

    @pytest.mark.asyncio
    async def test_create_player_round(
        crud_round_instance: CRUDRound,
        mock_firestore_db: MagicMock, # From conftest.py
        round_create_obj: RoundCreate,
        initial_parcels_data: list[dict],
        mock_round_doc_ref: MagicMock,
        mock_field_state_doc_ref: MagicMock
    ):
        # Arrange
        # Patch the helper methods that construct doc refs
        with patch.object(CRUDRound, "_get_round_doc_ref", return_value=mock_round_doc_ref) as mock_get_round_ref, \
             patch.object(CRUDRound, "_get_field_state_doc_ref", return_value=mock_field_state_doc_ref) as mock_get_field_ref, \
             patch("app.crud.crud_round.datetime") as mock_datetime: # Patch datetime used in crud_round.py

            mock_datetime.now.return_value = FIXED_DATETIME_ROUND
            mock_datetime.UTC = timezone.utc # Make sure timezone.utc is available if SUT uses datetime.UTC

            # Act
            created_round = await crud_round_instance.create_player_round(
                db=mock_firestore_db, obj_in=round_create_obj, initial_parcels=initial_parcels_data
            )

        # Assert
        mock_get_round_ref.assert_called_once_with(
            mock_firestore_db, TEST_GAME_ID_R, TEST_PLAYER_ID_R, TEST_ROUND_NUMBER_R
        )
        mock_get_field_ref.assert_called_once_with(
            mock_firestore_db, TEST_GAME_ID_R, TEST_PLAYER_ID_R, TEST_ROUND_NUMBER_R
        )

        # Check round document creation
        mock_round_doc_ref.set.assert_called_once()
        round_set_args, _ = mock_round_doc_ref.set.call_args
        round_set_data = round_set_args[0]

        assert round_set_data["game_id"] == round_create_obj.game_id
        assert round_set_data["player_id"] == round_create_obj.player_id
        assert round_set_data["round_number"] == round_create_obj.round_number
        assert round_set_data["is_submitted"] == round_create_obj.is_submitted
>       assert round_set_data["status"] == round_create_obj.status.value
E       AttributeError: 'str' object has no attribute 'value'

tests/crud/test_crud_round.py:107: AttributeError
=========================== short test summary info ============================
FAILED tests/crud/test_crud_admin.py::test_update_admin - AttributeError: 'st...
FAILED tests/crud/test_crud_admin.py::test_update_admin_ignores_password - At...
FAILED tests/crud/test_crud_game.py::test_get_games_by_admin_id_found - Asser...
FAILED tests/crud/test_crud_game.py::test_add_player_to_game_success - Assert...
FAILED tests/crud/test_crud_game.py::test_remove_player_from_game_success - A...
FAILED tests/crud/test_crud_game.py::test_get_game_by_id_found - AttributeErr...
FAILED tests/crud/test_crud_player.py::test_get_player_by_email_found - Asser...
FAILED tests/crud/test_crud_player.py::test_get_players_by_game_id_found - as...
FAILED tests/crud/test_crud_player.py::test_clear_temp_password_hash_failure_doc_not_found
FAILED tests/crud/test_crud_round.py::test_create_player_round - AttributeErr...
======================== 10 failed, 50 passed in 1.44s =========================
