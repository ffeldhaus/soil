/app/backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:208: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
============================= test session starts ==============================
platform linux -- Python 3.13.3, pytest-8.3.5, pluggy-1.6.0 -- /app/backend/.venv/bin/python
cachedir: .pytest_cache
rootdir: /app/backend
configfile: pyproject.toml
plugins: asyncio-1.0.0, cov-6.1.1, anyio-4.9.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 16 items

tests/crud/test_crud_player.py::test_create_player_with_uid FAILED       [  6%]
tests/crud/test_crud_player.py::test_get_player_by_email_found PASSED    [ 12%]
tests/crud/test_crud_player.py::test_get_player_by_email_not_found PASSED [ 18%]
tests/crud/test_crud_player.py::test_update_player PASSED                [ 25%]
tests/crud/test_crud_player.py::test_update_player_ignores_password PASSED [ 31%]
tests/crud/test_crud_player.py::test_get_players_by_game_id_found PASSED [ 37%]
tests/crud/test_crud_player.py::test_get_players_by_game_id_not_found PASSED [ 43%]
tests/crud/test_crud_player.py::test_get_player_in_game_by_number_found PASSED [ 50%]
tests/crud/test_crud_player.py::test_get_player_in_game_by_number_not_found PASSED [ 56%]
tests/crud/test_crud_player.py::test_clear_temp_password_hash_success PASSED [ 62%]
tests/crud/test_crud_player.py::test_clear_temp_password_hash_failure_doc_not_found PASSED [ 68%]
tests/crud/test_crud_player.py::test_get_player_by_id_found PASSED       [ 75%]
tests/crud/test_crud_player.py::test_get_player_by_id_not_found PASSED   [ 81%]
tests/crud/test_crud_player.py::test_remove_player_success PASSED        [ 87%]
tests/crud/test_crud_player.py::test_update_player_with_dict_input PASSED [ 93%]
tests/crud/test_crud_player.py::test_create_player_with_uid_dict_input FAILED [100%]

=================================== FAILURES ===================================
_________________________ test_create_player_with_uid __________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f18e4ef4f50>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139744893224336'>
player_create_obj = PlayerCreate(email='player.test@example.com', user_type=<UserType.PLAYER: 'player'>, is_active=True, is_superuser=Fals...ha', game_id='test-game-id-for-player-tests', player_number=1, is_ai=False, ai_strategy=None, password='playerpass789')

    @pytest.mark.asyncio
    async def test_create_player_with_uid(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        player_create_obj: PlayerCreate
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)

        # Data for the snapshot that .get() will return after .set()
        # This is what CRUDBase.create_with_uid will use to build the returned PlayerInDB
        expected_player_dict_from_get = {
            **BASE_PLAYER_IN_DB_DICT, # Start with base, override as needed
            "temp_password_hash": "hashed_temp_password_from_patch", # This is set by create_with_uid
            # created_at/updated_at will be FIXED_DATETIME_NOW_PLAYER due to patching datetime.now
        }
        # snapshot.to_dict() returns ISO strings for datetimes
        snap_dict_return = expected_player_dict_from_get.copy()
        snap_dict_return["created_at"] = FIXED_DATETIME_NOW_PLAYER.isoformat()
        snap_dict_return["updated_at"] = FIXED_DATETIME_NOW_PLAYER.isoformat()

        mock_snapshot_after_set = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_set.exists = True
        mock_snapshot_after_set.to_dict.return_value = snap_dict_return
        mock_snapshot_after_set.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_set) # Used by CRUDBase after set

        # Patch get_password_hash and datetime.now in app.crud.crud_player
        with patch("app.crud.crud_player.get_password_hash", return_value="hashed_temp_password_from_patch") as mock_hash, \
             patch("app.crud.crud_player.datetime") as mock_dt_crud_player: # For created_at/updated_at in Player
            mock_dt_crud_player.now.return_value = FIXED_DATETIME_NOW_PLAYER

>           created_player_dict_result = await crud_player_instance.create_with_uid(
                db=mock_firestore_db, uid=PLAYER_UID, obj_in=player_create_obj
            )

tests/crud/test_crud_player.py:123:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.crud.crud_player.CRUDPlayer object at 0x7f18e4ef4f50>
db = <AsyncMock spec='AsyncClient' id='139744893224336'>

    async def create_with_uid(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, uid: str, obj_in: Union[PlayerCreate, Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Create a new player document in Firestore with a specific UID.
        The password from PlayerCreate is for Firebase Auth.
        A hash of this password (if it's a temp password) is stored in Firestore.
        """
        plain_password: Optional[str]
        player_data_for_firestore: Dict[str, Any]

        if isinstance(obj_in, PlayerCreate):
            player_data_for_firestore = obj_in.model_dump(exclude_unset=True)
            # Ensure plain password is not in the data to be stored, it's for hashing only.
            # PlayerCreate model should have the password field.
            plain_password = player_data_for_firestore.pop("password", obj_in.password) # Get it from model attr if not in dump
        else: # obj_in is a dict
            player_data_for_firestore = dict(obj_in)
            plain_password = player_data_for_firestore.pop("password", None)

        if plain_password:
            player_data_for_firestore["temp_password_hash"] = get_password_hash(plain_password)
        else:
            # Password is required by PlayerCreate, so if dict doesn't have it, it's an issue
            # or implies a scenario where temp_password_hash is not set.
            player_data_for_firestore.setdefault("temp_password_hash", None)

        player_data_for_firestore["uid"] = uid
>       player_data_for_firestore["user_type"] = UserType.PLAYER.value # PlayerCreate has user_type, dict might not
E       NameError: name 'UserType' is not defined

app/crud/crud_player.py:59: NameError
____________________ test_create_player_with_uid_dict_input ____________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7f18e4f16a50>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139744896197232'>

    @pytest.mark.asyncio
    async def test_create_player_with_uid_dict_input(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient
    ):
        NEW_PLAYER_UID = "new-player-uid-dict"
        # The mock_firestore_db fixture ensures collection(...).document(...) returns a configurable AsyncMock
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(NEW_PLAYER_UID)

        create_dict = {
            "email": "dict_creator@example.com",
            "game_id": "game_for_dict_player",
            "player_number": 7,
            "username": "DictCreator",
            "password": "dict_raw_password",
            "is_ai": True,
            "ai_strategy": "Aggressive"
        }

        expected_player_data_in_db = {
            "uid": NEW_PLAYER_UID, "id": NEW_PLAYER_UID,
            "email": create_dict["email"],
            "game_id": create_dict["game_id"],
            "player_number": create_dict["player_number"],
            "username": create_dict["username"],
            "temp_password_hash": "hashed_temp_password_for_dict_input",
            "user_type": UserType.PLAYER.value,
            "is_active": True,
            "is_superuser": False,
            "created_at": FIXED_DATETIME_NOW_PLAYER.isoformat(),
            "updated_at": FIXED_DATETIME_NOW_PLAYER.isoformat(),
            "current_capital": 0.0,
            "is_ai": create_dict["is_ai"],
            "ai_strategy": create_dict["ai_strategy"]
        }

        mock_snapshot_after_set = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_set.exists = True
        mock_snapshot_after_set.to_dict.return_value = expected_player_data_in_db
        mock_snapshot_after_set.id = NEW_PLAYER_UID

        # Configure the specific doc_ref for this test
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_set)
        player_doc_ref.set = AsyncMock()

        with patch("app.crud.crud_player.get_password_hash", return_value="hashed_temp_password_for_dict_input") as mock_hash, \
             patch("app.crud.crud_player.datetime") as mock_dt_crud_player:
            mock_dt_crud_player.now.return_value = FIXED_DATETIME_NOW_PLAYER

>           created_player_dict_result = await crud_player_instance.create_with_uid(
                db=mock_firestore_db, uid=NEW_PLAYER_UID, obj_in=create_dict
            )

tests/crud/test_crud_player.py:736:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.crud.crud_player.CRUDPlayer object at 0x7f18e4f16a50>
db = <AsyncMock spec='AsyncClient' id='139744896197232'>

    async def create_with_uid(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, uid: str, obj_in: Union[PlayerCreate, Dict[str, Any]]
    ) -> Dict[str, Any]:
        """
        Create a new player document in Firestore with a specific UID.
        The password from PlayerCreate is for Firebase Auth.
        A hash of this password (if it's a temp password) is stored in Firestore.
        """
        plain_password: Optional[str]
        player_data_for_firestore: Dict[str, Any]

        if isinstance(obj_in, PlayerCreate):
            player_data_for_firestore = obj_in.model_dump(exclude_unset=True)
            # Ensure plain password is not in the data to be stored, it's for hashing only.
            # PlayerCreate model should have the password field.
            plain_password = player_data_for_firestore.pop("password", obj_in.password) # Get it from model attr if not in dump
        else: # obj_in is a dict
            player_data_for_firestore = dict(obj_in)
            plain_password = player_data_for_firestore.pop("password", None)

        if plain_password:
            player_data_for_firestore["temp_password_hash"] = get_password_hash(plain_password)
        else:
            # Password is required by PlayerCreate, so if dict doesn't have it, it's an issue
            # or implies a scenario where temp_password_hash is not set.
            player_data_for_firestore.setdefault("temp_password_hash", None)

        player_data_for_firestore["uid"] = uid
>       player_data_for_firestore["user_type"] = UserType.PLAYER.value # PlayerCreate has user_type, dict might not
E       NameError: name 'UserType' is not defined

app/crud/crud_player.py:59: NameError
=========================== short test summary info ============================
FAILED tests/crud/test_crud_player.py::test_create_player_with_uid - NameErro...
FAILED tests/crud/test_crud_player.py::test_create_player_with_uid_dict_input
========================= 2 failed, 14 passed in 0.54s =========================
