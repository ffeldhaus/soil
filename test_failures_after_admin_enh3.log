/app/backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:208: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
============================= test session starts ==============================
platform linux -- Python 3.13.3, pytest-8.3.5, pluggy-1.6.0 -- /app/backend/.venv/bin/python
cachedir: .pytest_cache
rootdir: /app/backend
configfile: pyproject.toml
plugins: asyncio-1.0.0, cov-6.1.1, anyio-4.9.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collecting ... collected 15 items

tests/crud/test_crud_admin.py::test_create_admin_with_uid PASSED         [  6%]
tests/crud/test_crud_admin.py::test_get_admin_by_email_found PASSED      [ 13%]
tests/crud/test_crud_admin.py::test_get_admin_by_email_not_found PASSED  [ 20%]
tests/crud/test_crud_admin.py::test_update_admin PASSED                  [ 26%]
tests/crud/test_crud_admin.py::test_update_admin_ignores_password PASSED [ 33%]
tests/crud/test_crud_admin.py::test_update_admin_non_existent PASSED     [ 40%]
tests/crud/test_crud_admin.py::test_get_admin_by_id_found PASSED         [ 46%]
tests/crud/test_crud_admin.py::test_get_admin_by_id_not_found PASSED     [ 53%]
tests/crud/test_crud_admin.py::test_get_multi_admins PASSED              [ 60%]
tests/crud/test_crud_admin.py::test_get_multi_admins_empty PASSED        [ 66%]
tests/crud/test_crud_admin.py::test_remove_admin_success PASSED          [ 73%]
tests/crud/test_crud_admin.py::test_remove_admin_non_existent PASSED     [ 80%]
tests/crud/test_crud_admin.py::test_get_admin_non_existent_base_path PASSED [ 86%]
tests/crud/test_crud_admin.py::test_update_admin_non_existent_base_path FAILED [ 93%]
tests/crud/test_crud_admin.py::test_create_admin_with_uid_fails_to_retrieve_after_set PASSED [100%]

=================================== FAILURES ===================================
___________________ test_update_admin_non_existent_base_path ___________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7f177b2f9d90>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='139738826155616'>
admin_update_obj = AdminUpdate(email='updated.admin@example.com', first_name='UpdatedTest', last_name='AdminUser', institution='Updated University', is_active=None, password=None)

    @pytest.mark.asyncio
    async def test_update_admin_non_existent_base_path(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_update_obj: AdminUpdate # An update object
    ):
        # This test targets CRUDBase.update when the document does not exist.
        NON_EXISTENT_UID = "truly-non-existent-for-update"
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS) # This is an AsyncMock for the collection

        # Create a new mock for the specific document ID we are testing
        mock_doc_ref_for_this_test = AsyncMock(spec=DocumentReference)
        snapshot_does_not_exist = MagicMock(spec=DocumentSnapshot)
        snapshot_does_not_exist.exists = False
        mock_doc_ref_for_this_test.get = AsyncMock(return_value=snapshot_does_not_exist)
        # This is the .update() we will assert was not called
        mock_doc_ref_for_this_test.update = AsyncMock()

        # Configure mock_collection_ref.document (which is a MagicMock itself)
        # to return this specific mock_doc_ref_for_this_test ONLY when called with NON_EXISTENT_UID.
        def document_side_effect(doc_id_called):
            if doc_id_called == NON_EXISTENT_UID:
                return mock_doc_ref_for_this_test
            # Fallback for any other document IDs if they were unexpectedly called during this test
            # This helps isolate the test to the specific document ID.
            generic_fallback_doc_ref = AsyncMock(spec=DocumentReference)
            generic_fallback_doc_ref.get = AsyncMock(return_value=MagicMock(spec=DocumentSnapshot, exists=True)) # Default to existing for other calls
            return generic_fallback_doc_ref

            # mock_collection_ref.document = MagicMock(side_effect=document_side_effect) # Using simpler return_value for this test
            mock_collection_ref.document.return_value = mock_doc_ref_for_this_test

        # Patch datetime.now() in app.crud.crud_admin.py as it's used by CRUDAdmin.update
        # This is needed because CRUDAdmin.update unconditionally adds 'updated_at' to the update_data
        # before calling super().update(). If the document doesn't exist, super().update should return None
        # before this data is used for an actual Firestore update call.
        with patch("app.crud.crud_admin.datetime") as mock_datetime_crud_admin_module:
            mock_datetime_crud_admin_module.now.return_value = FIXED_DATETIME_LATER

>           updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=NON_EXISTENT_UID, obj_in=admin_update_obj
            )

tests/crud/test_crud_admin.py:690:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
app/crud/crud_admin.py:116: in update
    return await super().update(db, doc_id=doc_id, obj_in=update_data) # super().update is from CRUDBase
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.crud.crud_admin.CRUDAdmin object at 0x7f177b2f9d90>
db = <AsyncMock spec='AsyncClient' id='139738826155616'>

    async def update(
        self, db: Union[AsyncFirestoreClient, BaseClient], *, doc_id: str, obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> Optional[Dict[str, Any]]:
        """
        Update an existing document by its ID.

        Args:
            db: Firestore client instance.
            doc_id: The ID of the document to update.
            obj_in: The Pydantic schema or dict containing data to update.
                      Fields not present will not be changed. To remove a field,
                      you might need to pass `firestore.DELETE_FIELD`.

        Returns:
            The updated document data as a dictionary, or None if the document doesn't exist.
        """
        doc_ref: DocumentReference = db.collection(self.collection_name).document(doc_id)

        if isinstance(obj_in, BaseModel):
            update_data = obj_in.model_dump(exclude_unset=True, exclude_none=True) # Don't send None values unless intended
        else:
            update_data = dict(obj_in)

        if not update_data: # Nothing to update
            snapshot = await doc_ref.get()
            if snapshot.exists:
                existing_data = snapshot.to_dict()
                existing_data["id"] = snapshot.id
                if "uid" not in existing_data and hasattr(self.model_schema, "uid"):
                     existing_data["uid"] = snapshot.id
                return existing_data
            return None

        await doc_ref.update(update_data)

>       snapshot = await doc_ref.get() # Fetch the updated document
E       TypeError: object MagicMock can't be used in 'await' expression

app/crud/base.py:227: TypeError
=========================== short test summary info ============================
FAILED tests/crud/test_crud_admin.py::test_update_admin_non_existent_base_path
========================= 1 failed, 14 passed in 0.26s =========================
