============================= test session starts ==============================
platform linux -- Python 3.13.3, pytest-8.3.5, pluggy-1.6.0
rootdir: /app/backend
configfile: pyproject.toml
plugins: asyncio-1.0.0, cov-6.1.1, anyio-4.9.0
asyncio: mode=Mode.AUTO, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 26 items

tests/crud/test_crud_admin.py FF.FFF......                               [ 46%]
tests/crud/test_crud_player.py FF.F.FFFF.FF..                            [100%]

=================================== FAILURES ===================================
__________________________ test_create_admin_with_uid __________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe4ae6f9090>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620149393120'>
admin_create_obj = AdminCreate(email='admin@example.com', user_type=<UserType.ADMIN: 'admin'>, is_active=True, is_superuser=False, first_name='Test', last_name='Admin', full_name=None, institution='Test University', password='securepassword123')
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620149397824'>

    @pytest.mark.asyncio
    async def test_create_admin_with_uid(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_create_obj: AdminCreate,
        mock_doc_snapshot: MagicMock # Used to mock the .get() call after .set()
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        # document(ADMIN_UID) is already configured by mock_doc_snapshot to return it on .get()
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        # Patch 'get_password_hash' and 'datetime' in 'app.crud.crud_admin'
        with patch("app.crud.crud_admin.get_password_hash", return_value="hashed_password_example_from_get_password_hash") as mock_hash, \
             patch("app.crud.crud_admin.datetime") as mock_datetime_module:
            mock_datetime_module.now.return_value = FIXED_DATETIME_NOW
            mock_datetime_module.utcnow.return_value = FIXED_DATETIME_NOW # If utcnow is used (some CRUD methods might use it for consistency)

            # Act - Single call to the method under test
            created_admin_dict = await crud_admin_instance.create_with_uid(
                db=mock_firestore_db, uid=ADMIN_UID, obj_in=admin_create_obj
            )

        # Assert
        assert created_admin_dict is not None, "create_with_uid should return a dictionary."
        # Ensure the dictionary from Firestore can be parsed into AdminInDB model
        created_admin = AdminInDB(**created_admin_dict)

        # 1. Check what was passed to Firestore's .set() method on the specific mock_doc_ref
        # The mock_doc_ref_for_admin_uid is already configured by mock_firestore_db fixture
        # to be the one associated with ADMIN_UID.
        mock_doc_ref_for_admin_uid.set.assert_called_once()
        args_to_set, _ = mock_doc_ref_for_admin_uid.set.call_args
        actual_set_data = args_to_set[0]

>       assert actual_set_data["uid"] == ADMIN_UID
E       KeyError: 'uid'

tests/crud/test_crud_admin.py:150: KeyError
________________________ test_get_admin_by_email_found _________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe4ae217250>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620149400512'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620151882816'>

    @pytest.mark.asyncio
    async def test_get_admin_by_email_found(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # This snapshot is configured with ADMIN_EMAIL
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        # Setup for .where().limit().stream()
        # This complex mocking is to ensure the chained calls .where().limit().stream() work as expected.
        mock_query_obj = AsyncMock() # This will be returned by .where()
        mock_limit_query_obj = AsyncMock() # This will be returned by .limit()

        async def stream_results_generator(*args, **kwargs): # The async generator for .stream()
            yield mock_doc_snapshot

        mock_limit_query_obj.stream = stream_results_generator # .stream() method returns the generator
        mock_query_obj.limit = MagicMock(return_value=mock_limit_query_obj) # .limit() method returns mock_limit_query_obj
        mock_collection_ref.where = MagicMock(return_value=mock_query_obj) # .where() method returns mock_query_obj

        # Act
        admin = await crud_admin_instance.get_by_email(db=mock_firestore_db, email=ADMIN_EMAIL)

        # Assert
        assert admin is not None
        # mock_doc_snapshot data is based on ADMIN_IN_DB_DICT_BASE and fixture timestamps
        assert admin.uid == ADMIN_UID
        assert admin.email == ADMIN_EMAIL
        assert admin.full_name == ADMIN_IN_DB_DICT_BASE["full_name"]
        assert admin.first_name == ADMIN_IN_DB_DICT_BASE["first_name"]
        assert admin.last_name == ADMIN_IN_DB_DICT_BASE["last_name"]
        assert admin.institution == ADMIN_IN_DB_DICT_BASE["institution"]
>       assert admin.is_superuser == ADMIN_IN_DB_DICT_BASE["is_superuser"]

tests/crud/test_crud_admin.py:241:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = AdminInDB(email='admin@example.com', user_type='admin', is_active=True, is_superuser=False, first_name='Test', last_name='Admin', full_name='Test Admin', institution='Test University', uid='test-admin-uid', created_at=datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc), updated_at=datetime.datetime(2023, 1, 1, 12, 0, tzinfo=datetime.timezone.utc))
item = 'is_superuser'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'AdminInDB' object has no attribute 'is_superuser'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
______________________________ test_update_admin _______________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe4ae2a7e10>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620151892560'>
admin_update_obj = AdminUpdate(email='updated.admin@example.com', first_name='UpdatedTest', last_name='AdminUser', institution='Updated University', is_active=None, password=None)
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620151897264'>

    @pytest.mark.asyncio
    async def test_update_admin(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_update_obj: AdminUpdate,
        mock_doc_snapshot: MagicMock # Represents state *before* update for the first .get()
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        # Data for snapshot returned *after* update.
        # This should reflect the changes made by admin_update_obj.
        # Original created_at, user_type, and hashed_password should remain.
        original_doc_data_before_update = mock_doc_snapshot.to_dict() # Data from ADMIN_IN_DB_DICT_BASE + timestamps
        expected_full_name_after_update = f"{admin_update_obj.first_name} {admin_update_obj.last_name}"

        data_after_update_dict = {
            **original_doc_data_before_update, # Start with existing data
            "first_name": admin_update_obj.first_name,
            "last_name": admin_update_obj.last_name,
            "full_name": expected_full_name_after_update,
            "email": admin_update_obj.email,
            "institution": admin_update_obj.institution,
            "updated_at": FIXED_DATETIME_LATER, # This will be set by the update method in CRUDAdmin
            # Fields that should NOT change:
            "created_at": original_doc_data_before_update["created_at"],
            "hashed_password": original_doc_data_before_update["hashed_password"],
            "user_type": original_doc_data_before_update["user_type"],
            "is_superuser": original_doc_data_before_update["is_superuser"],
            # is_active can be changed by AdminUpdate, so if it's in admin_update_obj, it should be here
            "is_active": admin_update_obj.is_active if admin_update_obj.is_active is not None else original_doc_data_before_update["is_active"],
        }

        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = data_after_update_dict
        mock_snapshot_after_update.id = ADMIN_UID

        # CRUDBase.update calls doc_ref.update() then doc_ref.get().
        # The mock_doc_snapshot fixture (passed to this test) represents the state *before* this update.
        # It's used by CRUDBase if it internally calls .get() before .update() (which it doesn't explicitly).
        # More importantly, the .get() *after* the .update() call needs to return the new state.
        mock_doc_ref_for_admin_uid.get = AsyncMock(return_value=mock_snapshot_after_update)


        # Patch datetime.now() in app.crud.crud_admin.py as it's used by CRUDAdmin.update
        with patch("app.crud.crud_admin.datetime") as mock_datetime_crud_admin_module:
            # Mock datetime.now(timezone.utc) specifically if that's what's used.
            # If it's just datetime.now(), this is fine.
            mock_datetime_crud_admin_module.now.return_value = FIXED_DATETIME_LATER # Time of update

            # Act
            updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=ADMIN_UID, obj_in=admin_update_obj
            )

        # Assert
        assert updated_admin_dict is not None, "Update should return the updated admin dictionary."
        updated_admin = AdminInDB(**updated_admin_dict)

        # 1. Check what was passed to Firestore's .update() method
        mock_doc_ref_for_admin_uid.update.assert_called_once()
        args_to_update, _ = mock_doc_ref_for_admin_uid.update.call_args
        actual_update_payload = args_to_update[0]

        assert "password" not in actual_update_payload, "Plain password should not be in Firestore update payload."
        assert "hashed_password" not in actual_update_payload, "Hashed password should not be sent directly in this payload."
        assert actual_update_payload["first_name"] == admin_update_obj.first_name
        assert actual_update_payload["last_name"] == admin_update_obj.last_name
        assert actual_update_payload["email"] == admin_update_obj.email
        assert actual_update_payload["institution"] == admin_update_obj.institution
        assert actual_update_payload["full_name"] == expected_full_name_after_update
        assert actual_update_payload["updated_at"] == FIXED_DATETIME_LATER # This must be set by CRUDAdmin.update
        if admin_update_obj.is_active is not None:
            assert actual_update_payload["is_active"] == admin_update_obj.is_active

        # 2. Check the returned AdminInDB object (comes from the .get() call after update)
        assert updated_admin.first_name == admin_update_obj.first_name
        assert updated_admin.full_name == expected_full_name_after_update
        assert updated_admin.email == admin_update_obj.email
        assert updated_admin.institution == admin_update_obj.institution
        if admin_update_obj.is_active is not None:
            assert updated_admin.is_active == admin_update_obj.is_active
        else:
            assert updated_admin.is_active == original_doc_data_before_update["is_active"]

        assert updated_admin.updated_at == FIXED_DATETIME_LATER
        assert updated_admin.created_at == original_doc_data_before_update["created_at"], "created_at should not change."
>       assert updated_admin.user_type.value == original_doc_data_before_update["user_type"], "user_type should not change by default."
E       AttributeError: 'str' object has no attribute 'value'

tests/crud/test_crud_admin.py:334: AttributeError
______________________ test_update_admin_ignores_password ______________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe4ae5b1490>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620151891216'>
mock_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620154242784'>

    @pytest.mark.asyncio
    async def test_update_admin_ignores_password(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        mock_doc_snapshot: MagicMock # Represents current state in DB (before this specific test's update)
    ):
        # Arrange
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS)
        mock_doc_ref_for_admin_uid = mock_collection_ref.document(ADMIN_UID)

        original_doc_data = mock_doc_snapshot.to_dict()
        original_hashed_password = original_doc_data["hashed_password"]
        original_created_at = original_doc_data["created_at"]
        original_user_type_str = original_doc_data["user_type"] # e.g., "admin"
        original_is_superuser = original_doc_data["is_superuser"]
        original_is_active = original_doc_data["is_active"]


        update_payload_with_password = AdminUpdate(
            first_name="PasswordTestFirstName", # Changed field
            # last_name, email, institution will be None, so they shouldn't be in payload unless model_dump(exclude_none=False)
            # CRUDAdmin.update uses obj_in.model_dump(exclude_unset=True, exclude_none=True)
            # So only first_name and password (which is then deleted) will be in update_data from AdminUpdate.
            password="newfakepassword123" # This should be ignored by CRUDAdmin.update logic
        )

        # Data for snapshot returned *after* this specific update attempt.
        # Only first_name and updated_at should change. Password-related fields remain untouched.
        data_after_update_attempt_dict = {
            **original_doc_data, # Start with existing data
            "first_name": update_payload_with_password.first_name,
            # full_name should also update if first_name changes and last_name is present
            "full_name": f"{update_payload_with_password.first_name} {original_doc_data['last_name']}",
            "updated_at": FIXED_DATETIME_LATER, # This will be set by CRUDAdmin.update
            # Fields that should NOT change:
            "hashed_password": original_hashed_password,
            "created_at": original_created_at,
            "user_type": original_user_type_str,
            "email": original_doc_data["email"], # Unchanged as not in update_payload_with_password
            "last_name": original_doc_data["last_name"], # Unchanged
            "institution": original_doc_data["institution"], # Unchanged
            "is_superuser": original_is_superuser, # Unchanged
            "is_active": original_is_active, # Unchanged
        }
        mock_snapshot_after_update_attempt = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update_attempt.exists = True
        mock_snapshot_after_update_attempt.to_dict.return_value = data_after_update_attempt_dict
        mock_snapshot_after_update_attempt.id = ADMIN_UID

        # Configure .get() on the specific doc ref to return the state *after* the update call
        mock_doc_ref_for_admin_uid.get = AsyncMock(return_value=mock_snapshot_after_update_attempt)

        with patch("app.crud.crud_admin.datetime") as mock_datetime_module:
            mock_datetime_module.now.return_value = FIXED_DATETIME_LATER # Time of update

            # Act
            updated_admin_dict = await crud_admin_instance.update(
                db=mock_firestore_db, doc_id=ADMIN_UID, obj_in=update_payload_with_password
            )

        # Assert
        assert updated_admin_dict is not None, "Update should return a dictionary even if only timestamps change."
        updated_admin = AdminInDB(**updated_admin_dict)

        # 1. Check what was passed to Firestore's .update() method
        mock_doc_ref_for_admin_uid.update.assert_called_once()
        args_to_update, _ = mock_doc_ref_for_admin_uid.update.call_args
        actual_update_payload = args_to_update[0]

        assert "password" not in actual_update_payload, "Plain password should NOT be in Firestore update payload."
        assert "hashed_password" not in actual_update_payload, "Hashed password should NOT be in this update payload."
        assert actual_update_payload["first_name"] == update_payload_with_password.first_name
        assert "last_name" not in actual_update_payload # Was not in AdminUpdate with exclude_none=True
        assert "email" not in actual_update_payload # Was not in AdminUpdate
        assert actual_update_payload["full_name"] == f"{update_payload_with_password.first_name} {original_doc_data['last_name']}"
        assert actual_update_payload["updated_at"] == FIXED_DATETIME_LATER

        # 2. Check the returned AdminInDB object
        assert updated_admin.first_name == update_payload_with_password.first_name
        assert updated_admin.full_name == f"{update_payload_with_password.first_name} {original_doc_data['last_name']}"
        assert updated_admin.email == original_doc_data["email"] # Unchanged
>       assert updated_admin.hashed_password == original_hashed_password, "Hashed password must remain unchanged."

tests/crud/test_crud_admin.py:419:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = AdminInDB(email='admin@example.com', user_type='admin', is_active=True, is_superuser=False, first_name='PasswordTestFir...1, 12, 0, tzinfo=datetime.timezone.utc), updated_at=datetime.datetime(2023, 1, 1, 13, 0, tzinfo=datetime.timezone.utc))
item = 'hashed_password'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'AdminInDB' object has no attribute 'hashed_password'

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
________________________ test_update_admin_non_existent ________________________

crud_admin_instance = <app.crud.crud_admin.CRUDAdmin object at 0x7fe4ae3d3460>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620154243456'>
admin_update_obj = AdminUpdate(email='updated.admin@example.com', first_name='UpdatedTest', last_name='AdminUser', institution='Updated University', is_active=None, password=None)
mock_doc_snapshot_non_existent = <MagicMock spec='DocumentSnapshot' id='140620154250848'>

    @pytest.mark.asyncio
    async def test_update_admin_non_existent(
        crud_admin_instance: CRUDAdmin,
        mock_firestore_db: AsyncFirestoreClient,
        admin_update_obj: AdminUpdate,
        mock_doc_snapshot_non_existent: MagicMock # Configured for "non-existent-admin-uid"
    ):
        # Arrange
        # mock_firestore_db.collection().document("non-existent-admin-uid").get is already mocked by the fixture

        # Act
        # No need to patch datetime if .get() returns non-existent, as .update won't be called.
        updated_admin_dict = await crud_admin_instance.update(
            db=mock_firestore_db, doc_id="non-existent-admin-uid", obj_in=admin_update_obj
        )

        # Assert
        assert updated_admin_dict is None
>       mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_ADMINS).document("non-existent-admin-uid").update.assert_not_called()

tests/crud/test_crud_admin.py:444:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='mock.update' id='140620154249168'>

    def assert_not_called(self):
        """assert that the mock was never called.
        """
        if self.call_count != 0:
            msg = ("Expected '%s' to not have been called. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'update' to not have been called. Called 1 times.
E           Calls: [call({'email': 'updated.admin@example.com', 'first_name': 'UpdatedTest', 'last_name': 'AdminUser', 'institution': 'Updated University', 'full_name': 'UpdatedTest AdminUser', 'updated_at': datetime.datetime(2025, 5, 30, 23, 3, 29, 70080, tzinfo=datetime.timezone.utc)})].

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:940: AssertionError
_________________________ test_create_player_with_uid __________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae6f8cd0>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620154247488'>
player_create_obj = PlayerCreate(email='player.test@example.com', user_type=<UserType.PLAYER: 'player'>, is_active=True, is_superuser=Fals...ha', game_id='test-game-id-for-player-tests', player_number=1, is_ai=False, ai_strategy=None, password='playerpass789')

    @pytest.mark.asyncio
    async def test_create_player_with_uid(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        player_create_obj: PlayerCreate
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)

        # Data for the snapshot that .get() will return after .set()
        # This is what CRUDBase.create_with_uid will use to build the returned PlayerInDB
        expected_player_dict_from_get = {
            **BASE_PLAYER_IN_DB_DICT, # Start with base, override as needed
            "temp_password_hash": "hashed_temp_password_from_patch", # This is set by create_with_uid
            # created_at/updated_at will be FIXED_DATETIME_NOW_PLAYER due to patching datetime.now
        }
        # snapshot.to_dict() returns ISO strings for datetimes
        snap_dict_return = expected_player_dict_from_get.copy()
        snap_dict_return["created_at"] = FIXED_DATETIME_NOW_PLAYER.isoformat()
        snap_dict_return["updated_at"] = FIXED_DATETIME_NOW_PLAYER.isoformat()

        mock_snapshot_after_set = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_set.exists = True
        mock_snapshot_after_set.to_dict.return_value = snap_dict_return
        mock_snapshot_after_set.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_set) # Used by CRUDBase after set

        # Patch get_password_hash and datetime.now in app.crud.crud_player
        with patch("app.crud.crud_player.get_password_hash", return_value="hashed_temp_password_from_patch") as mock_hash, \
             patch("app.crud.crud_player.datetime") as mock_dt_crud_player: # For created_at/updated_at in Player
            mock_dt_crud_player.now.return_value = FIXED_DATETIME_NOW_PLAYER

            created_player_dict_result = await crud_player_instance.create_with_uid(
                db=mock_firestore_db, uid=PLAYER_UID, obj_in=player_create_obj
            )

        assert created_player_dict_result is not None
        created_player = PlayerInDB(**created_player_dict_result)

        mock_hash.assert_called_once_with(player_create_obj.password)

        # Check data passed to Firestore .set()
        player_doc_ref.set.assert_called_once()
        actual_set_data = player_doc_ref.set.call_args[0][0]

        assert actual_set_data["uid"] == PLAYER_UID
        assert actual_set_data["email"] == player_create_obj.email
        assert actual_set_data["temp_password_hash"] == "hashed_temp_password_from_patch"
        # Timestamps are set by CRUDPlayer.create_with_uid (which calls super().create_with_uid)
        # CRUDBase.create_with_uid does NOT add timestamps itself to the data it passes to .set()
        # It relies on what's in obj_in. CRUDPlayer.create_with_uid adds them to its internal dict.
        # The patch for app.crud.crud_player.datetime ensures these are fixed.
        # However, CRUDPlayer.create_with_uid in the actual code doesn't add created_at/updated_at.
        # This logic was in CRUDAdmin. Player.create_with_uid now adds created_at/updated_at.
        assert actual_set_data["created_at"] == FIXED_DATETIME_NOW_PLAYER
        assert actual_set_data["updated_at"] == FIXED_DATETIME_NOW_PLAYER
        assert "password" not in actual_set_data # Plain password should not be stored

        # Verify all fields from PlayerCreate are present and correct
        assert actual_set_data["game_id"] == player_create_obj.game_id
        assert actual_set_data["player_number"] == player_create_obj.player_number
        assert actual_set_data["username"] == player_create_obj.username
        assert actual_set_data["is_ai"] == player_create_obj.is_ai
        assert actual_set_data["user_type"] == UserType.PLAYER.value # Set by CRUDPlayer

        # Verify defaults like is_active (is_superuser is not in PlayerCreate/UserBase)
        # PlayerCreate -> UserCreate -> UserBase. UserBase has is_active = True.
        # model_dump should include this default.
>       assert actual_set_data["is_active"] is True
E       KeyError: 'is_active'

tests/crud/test_crud_player.py:159: KeyError
________________________ test_get_player_by_email_found ________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae216990>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620154256224'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620149396816'>

    @pytest.mark.asyncio
    async def test_get_player_by_email_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock # Specific player snapshot
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query

        async def stream_results_gen(*args, **kwargs): yield mock_player_doc_snapshot
        # query.limit(1).stream() -> query.limit() returns a new query object.
        # So, the final object that .stream() is called on needs to have .stream mocked.
        mock_limit_query = AsyncMock(spec=AsyncQuery)
        mock_query.limit = MagicMock(return_value=mock_limit_query)
        mock_limit_query.stream = MagicMock(return_value=stream_results_gen())


        player_dict_or_model = await crud_player_instance.get_by_email(db=mock_firestore_db, email=PLAYER_EMAIL)
        assert player_dict_or_model is not None
        player = player_dict_or_model # Changed: crud.get_by_email returns a model instance

        # Comprehensive assertions
        assert player.uid == PLAYER_UID
>       assert player.id == PLAYER_UID

tests/crud/test_crud_player.py:203:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PlayerInDB(email='player.test@example.com', user_type='player', is_active=True, is_superuser=False, username='TestPlay...me.datetime(2023, 1, 2, 10, 0, tzinfo=TzInfo(UTC)), temp_password_hash='initial_hashed_temp_pass', current_capital=0.0)
item = 'id'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'PlayerInDB' object has no attribute 'id'. Did you mean: 'uid'?

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
______________________________ test_update_player ______________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae2a7490>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620151702256'>
player_update_obj = PlayerUpdate(username='TestPlayerAlphaUpdated', password=None, is_active=False)
mock_player_doc_snapshot_data = {'ai_strategy': None, 'created_at': '2023-01-02T10:00:00+00:00', 'current_capital': 0.0, 'email': 'player.test@example.com', ...}

    @pytest.mark.asyncio
    async def test_update_player(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        player_update_obj: PlayerUpdate,
        mock_player_doc_snapshot_data: dict # Base data for the player
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)

        # Data for snapshot *after* update
        data_after_update_dict = {
            **mock_player_doc_snapshot_data, # Contains original created_at, email etc. as ISO strings
            "username": player_update_obj.username,
            "is_active": player_update_obj.is_active,
            "updated_at": FIXED_DATETIME_LATER_PLAYER.isoformat() # Updated timestamp as ISO string
        }
        mock_snapshot_after_update = MagicMock(spec=DocumentSnapshot)
        mock_snapshot_after_update.exists = True
        mock_snapshot_after_update.to_dict.return_value = data_after_update_dict
        mock_snapshot_after_update.id = PLAYER_UID
        player_doc_ref.get = AsyncMock(return_value=mock_snapshot_after_update) # CRUDBase.update calls .get()

        # Patch datetime.now() in app.crud.crud_player (used by CRUDPlayer.update)
        with patch("app.crud.crud_player.datetime") as mock_dt_player: # CRUDBase does not set timestamps, only CRUDPlayer
            mock_dt_player.now.return_value = FIXED_DATETIME_LATER_PLAYER

            updated_player_dict = await crud_player_instance.update(
                db=mock_firestore_db, doc_id=PLAYER_UID, obj_in=player_update_obj
            )

        assert updated_player_dict is not None
        updated_player = PlayerInDB(**updated_player_dict) # Pydantic parses ISO strings

        # Check Firestore .update() call payload
        player_doc_ref.update.assert_called_once()
        update_call_payload = player_doc_ref.update.call_args[0][0]
        assert update_call_payload["username"] == player_update_obj.username
        assert update_call_payload["is_active"] == player_update_obj.is_active
        assert update_call_payload["updated_at"] == FIXED_DATETIME_LATER_PLAYER # Set by CRUDPlayer.update

        assert updated_player.username == player_update_obj.username
        assert updated_player.is_active == player_update_obj.is_active
        assert updated_player.updated_at == FIXED_DATETIME_LATER_PLAYER
        # Verify fields that should not change
        original_player_data = mock_player_doc_snapshot_data # This has ISO dates
        assert updated_player.created_at == FIXED_DATETIME_NOW_PLAYER # From original snapshot data
        assert updated_player.email == original_player_data["email"]
        assert updated_player.temp_password_hash == original_player_data["temp_password_hash"]
        assert updated_player.game_id == original_player_data["game_id"]
        assert updated_player.player_number == original_player_data["player_number"]
>       assert updated_player.user_type.value == original_player_data["user_type"] # Compare string value to string value
E       AttributeError: 'str' object has no attribute 'value'

tests/crud/test_crud_player.py:292: AttributeError
______________________ test_get_players_by_game_id_found _______________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae3d1150>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620148960496'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620153035408'>

    @pytest.mark.asyncio
    async def test_get_players_by_game_id_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query # .where().limit() if limit is part of query

        async def stream_results_gen(*args, **kwargs): yield mock_player_doc_snapshot
        mock_query.stream = MagicMock(return_value=stream_results_gen())

        players_list = await crud_player_instance.get_players_by_game_id(
            db=mock_firestore_db, game_id=TEST_GAME_ID_FOR_PLAYER, limit=10 # Explicit limit
        )

>       mock_collection_ref.where.assert_called_once_with("game_id", "==", TEST_GAME_ID_FOR_PLAYER)

tests/crud/test_crud_player.py:362:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='140620153033392'>
args = ('game_id', '==', 'test-game-id-for-player-tests'), kwargs = {}
expected = call('game_id', '==', 'test-game-id-for-player-tests')
actual = call(field='game_id', op_string='==', value='test-game-id-for-player-tests')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe4ae5fdc60>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('game_id', '==', 'test-game-id-for-player-tests')
E             Actual: where(field='game_id', op_string='==', value='test-game-id-for-player-tests')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
____________________ test_get_players_by_game_id_not_found _____________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae3d2250>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620148950416'>

    @pytest.mark.asyncio
    async def test_get_players_by_game_id_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query = AsyncMock(spec=AsyncQuery)
        mock_collection_ref.where.return_value = mock_query

        async def stream_no_results(*args, **kwargs):
            if False: yield # Empty async generator
        mock_query.stream = MagicMock(return_value=stream_no_results()) # After .limit()

        players_list = await crud_player_instance.get_players_by_game_id(
            db=mock_firestore_db, game_id="non-existent-game-id", limit=5
        )
>       mock_collection_ref.where.assert_called_once_with("game_id", "==", "non-existent-game-id")

tests/crud/test_crud_player.py:399:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='mock.where' id='140620148953776'>
args = ('game_id', '==', 'non-existent-game-id'), kwargs = {}
expected = call('game_id', '==', 'non-existent-game-id')
actual = call(field='game_id', op_string='==', value='non-existent-game-id')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe4ae5fe200>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: where('game_id', '==', 'non-existent-game-id')
E             Actual: where(field='game_id', op_string='==', value='non-existent-game-id')

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
___________________ test_get_player_in_game_by_number_found ____________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae38a250>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620149237344'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620149406896'>

    @pytest.mark.asyncio
    async def test_get_player_in_game_by_number_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient,
        mock_player_doc_snapshot: MagicMock
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        # Mocking the chain: collection.where().where().limit().stream()
        mock_query_game_id = AsyncMock(spec=AsyncQuery) # After first .where()
        mock_query_player_num = AsyncMock(spec=AsyncQuery) # After second .where()
        mock_query_limit = AsyncMock(spec=AsyncQuery)      # After .limit()

        mock_collection_ref.where.return_value = mock_query_game_id
        mock_query_game_id.where.return_value = mock_query_player_num
        mock_query_player_num.limit.return_value = mock_query_limit

        async def stream_one_result(*args, **kwargs):
            yield mock_player_doc_snapshot
        mock_query_limit.stream = MagicMock(return_value=stream_one_result())

        player_dict_or_model = await crud_player_instance.get_player_in_game_by_number(
            db=mock_firestore_db, game_id=TEST_GAME_ID_FOR_PLAYER, player_number=PLAYER_NUMBER
        )
        assert player_dict_or_model is not None
        player = player_dict_or_model # Changed: crud method returns a model instance

        # Assert correct query construction
        calls = mock_collection_ref.where.call_args_list
>       assert calls[0][0] == ("game_id", "==", TEST_GAME_ID_FOR_PLAYER) # First where call
E       AssertionError: assert () == ('game_id', '...player-tests')
E
E         Right contains 3 more items, first extra item: 'game_id'
E         Use -v to get more diff

tests/crud/test_crud_player.py:431: AssertionError
_________________ test_get_player_in_game_by_number_not_found __________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae388a50>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620149405888'>

    @pytest.mark.asyncio
    async def test_get_player_in_game_by_number_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient
    ):
        mock_collection_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS)
        mock_query_game_id = AsyncMock(spec=AsyncQuery)
        mock_query_player_num = AsyncMock(spec=AsyncQuery)
        mock_query_limit = AsyncMock(spec=AsyncQuery)

        mock_collection_ref.where.return_value = mock_query_game_id
        mock_query_game_id.where.return_value = mock_query_player_num
        mock_query_player_num.limit.return_value = mock_query_limit

        async def stream_no_results(*args, **kwargs):
            if False: yield
        mock_query_limit.stream = MagicMock(return_value=stream_no_results())

        player = await crud_player_instance.get_player_in_game_by_number(
            db=mock_firestore_db, game_id="some-game-id", player_number=99
        )
        assert player is None
        calls = mock_collection_ref.where.call_args_list
>       assert calls[0][0] == ("game_id", "==", "some-game-id")
E       AssertionError: assert () == ('game_id', '...some-game-id')
E
E         Right contains 3 more items, first extra item: 'game_id'
E         Use -v to get more diff

tests/crud/test_crud_player.py:476: AssertionError
_____________ test_clear_temp_password_hash_failure_doc_not_found ______________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae2f5130>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620153032048'>

    @pytest.mark.asyncio
    async def test_clear_temp_password_hash_failure_doc_not_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient,
    ):
        # Patch the super().update() call within clear_temp_password_hash to simulate failure
        with patch.object(CRUDBase, "update", new_callable=AsyncMock) as mock_base_update:
            mock_base_update.return_value = None # Simulate document not found or update failure

            # We still need to patch datetime.now used by clear_temp_password_hash itself for its own updated_at
            with patch("app.crud.crud_player.datetime") as mock_dt_player:
                 mock_dt_player.now.return_value = FIXED_DATETIME_LATER_PLAYER

                 result_dict = await crud_player_instance.clear_temp_password_hash(
                    db=mock_firestore_db, player_uid="non-existent-player-uid"
                 )

        assert result_dict is None
        # Check that super().update was called correctly by clear_temp_password_hash
        expected_payload_to_base = {
            "temp_password_hash": None,
            "updated_at": FIXED_DATETIME_LATER_PLAYER
        }
>       mock_base_update.assert_called_once_with(
            db=mock_firestore_db, doc_id="non-existent-player-uid", obj_in=expected_payload_to_base
        )

tests/crud/test_crud_player.py:551:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:991: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <AsyncMock name='update' id='140620151891552'>, args = ()
kwargs = {'db': <AsyncMock spec='AsyncClient' id='140620153032048'>, 'doc_id': 'non-existent-player-uid', 'obj_in': {'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)}}
expected = call(db=<AsyncMock spec='AsyncClient' id='140620153032048'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
actual = call(<AsyncMock spec='AsyncClient' id='140620153032048'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x7fe4ae5ff060>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.

        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\n  Actual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)

        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: update(db=<AsyncMock spec='AsyncClient' id='140620153032048'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})
E             Actual: update(<AsyncMock spec='AsyncClient' id='140620153032048'>, doc_id='non-existent-player-uid', obj_in={'temp_password_hash': None, 'updated_at': datetime.datetime(2023, 1, 2, 11, 0, tzinfo=datetime.timezone.utc)})

/home/swebot/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/lib/python3.13/unittest/mock.py:979: AssertionError
_________________________ test_get_player_by_id_found __________________________

crud_player_instance = <app.crud.crud_player.CRUDPlayer object at 0x7fe4ae37c750>
mock_firestore_db = <AsyncMock spec='AsyncClient' id='140620151893232'>
mock_player_doc_snapshot = <MagicMock spec='DocumentSnapshot' id='140620152871232'>

    @pytest.mark.asyncio
    async def test_get_player_by_id_found(
        crud_player_instance: CRUDPlayer,
        mock_firestore_db: AsyncFirestoreClient, # From conftest.py
        mock_player_doc_snapshot: MagicMock # Specific player snapshot
    ):
        player_doc_ref = mock_firestore_db.collection(settings.FIRESTORE_COLLECTION_USERS).document(PLAYER_UID)
        player_doc_ref.get = AsyncMock(return_value=mock_player_doc_snapshot) # Ensure this specific doc ID returns our snapshot

        player_dict_or_model = await crud_player_instance.get(db=mock_firestore_db, doc_id=PLAYER_UID)
        assert player_dict_or_model is not None
        player = player_dict_or_model # Changed: crud.get returns a model instance

        # Comprehensive assertions
        assert player.uid == PLAYER_UID
>       assert player.id == PLAYER_UID

tests/crud/test_crud_player.py:571:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = PlayerInDB(email='player.test@example.com', user_type='player', is_active=True, is_superuser=False, username='TestPlay...me.datetime(2023, 1, 2, 10, 0, tzinfo=TzInfo(UTC)), temp_password_hash='initial_hashed_temp_pass', current_capital=0.0)
item = 'id'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore

            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None

            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'PlayerInDB' object has no attribute 'id'. Did you mean: 'uid'?

.venv/lib/python3.13/site-packages/pydantic/main.py:991: AttributeError
=========================== short test summary info ============================
FAILED tests/crud/test_crud_admin.py::test_create_admin_with_uid - KeyError: ...
FAILED tests/crud/test_crud_admin.py::test_get_admin_by_email_found - Attribu...
FAILED tests/crud/test_crud_admin.py::test_update_admin - AttributeError: 'st...
FAILED tests/crud/test_crud_admin.py::test_update_admin_ignores_password - At...
FAILED tests/crud/test_crud_admin.py::test_update_admin_non_existent - Assert...
FAILED tests/crud/test_crud_admin.py::test_get_admin_by_id_found - AttributeE...
FAILED tests/crud/test_crud_player.py::test_create_player_with_uid - KeyError...
FAILED tests/crud/test_crud_player.py::test_get_player_by_email_found - Attri...
FAILED tests/crud/test_crud_player.py::test_update_player - AttributeError: '...
FAILED tests/crud/test_crud_player.py::test_get_players_by_game_id_found - As...
FAILED tests/crud/test_crud_player.py::test_get_players_by_game_id_not_found
FAILED tests/crud/test_crud_player.py::test_get_player_in_game_by_number_found
FAILED tests/crud/test_crud_player.py::test_get_player_in_game_by_number_not_found
FAILED tests/crud/test_crud_player.py::test_clear_temp_password_hash_failure_doc_not_found
FAILED tests/crud/test_crud_player.py::test_get_player_by_id_found - Attribut...
======================== 15 failed, 11 passed in 1.18s =========================
 /app/backend/.venv/lib/python3.13/site-packages/pytest_asyncio/plugin.py:208: PytestDeprecationWarning: The configuration option "asyncio_default_fixture_loop_scope" is unset.
The event loop scope for asynchronous fixtures will default to the fixture caching scope. Future versions of pytest-asyncio will default the loop scope for asynchronous fixtures to function scope. Set the default fixture loop scope explicitly in order to avoid unexpected behavior in the future. Valid fixture loop scopes are: "function", "class", "module", "package", "session"

  warnings.warn(PytestDeprecationWarning(_DEFAULT_FIXTURE_LOOP_SCOPE_UNSET))
